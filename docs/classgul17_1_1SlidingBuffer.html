<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>General Utility Library for C++17: gul17::SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gul17.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">General Utility Library for C++17
   &#160;<span id="projectnumber">2.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegul17.html">gul17</a></li><li class="navelem"><a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classgul17_1_1SlidingBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gul17::SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__SlidingBuffer__h.html">gul17/SlidingBuffer.h</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ElementT, std::size_t fixed_capacity = 0u, typename Container = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt;<br />
class gul17::SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt;</h3>

<p>A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the back. </p>
<p>A <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> is a flat array containing zero to <a class="el" href="classgul17_1_1SlidingBuffer.html#a6e70351dc3956330ee3da795d84852f0" title="Return the maximum possible number of elements in the container.">capacity()</a> elements of an arbitrary type. The capacity can either be specified at compile time via a template parameter or at runtime via <a class="el" href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89" title="Resize the container.">resize()</a>. In the former case, the internal buffer is embedded in the object (std::array), in the latter case it is dynamically allocated (std::vector).</p>
<p>The <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> shares many characteristics with traditional ring buffers: It has a fixed maximum size and new elements are added with <a class="el" href="classgul17_1_1SlidingBuffer.html#a6b76a482abef03edeb5e419b3f0b9a37" title="Insert one element at the front of the buffer; if it is full, an element at the back is dropped to ma...">push_front()</a> or <a class="el" href="classgul17_1_1SlidingBuffer.html#a2dd0eeb815fc15462a54dfe0f5638c2d" title="Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...">push_back()</a>. If this is done when the buffer is <a class="el" href="classgul17_1_1SlidingBuffer.html#acad96b773ad51142cb20726fc421e861" title="Return true if the buffer is completely filled with elements.">filled()</a> to capacity, an element automatically drops out at the other end of the sliding window:</p>
<div class="fragment"><div class="line">SlidingBuffer&lt;int, 2&gt; buf; <span class="comment">// Create a buffer with up to 2 entries</span></div>
<div class="line"> </div>
<div class="line">buf.push_back(1);</div>
<div class="line">buf.push_back(2);</div>
<div class="line">buf.push_back(3);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; buf[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; buf[1] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="comment">// prints &quot;2, 3&quot;</span></div>
<div class="line"> </div>
<div class="line">buf.push_front(1);</div>
<div class="line">std::cout &lt;&lt; buf[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; buf[1] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="comment">// prints &quot;1, 2&quot;</span></div>
</div><!-- fragment --><p>This buffer is not intended for producer-consumer problems. If the elements access is atomic it is thread-safe though. All auxiliary functions that mutate the data are not thread safe.</p>
<p>Differing from arrays this buffer will start empty (with a size of zero). Once the buffer has grown to its designated size (i.e. capacity), its <a class="el" href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38" title="Return the number of elements in the container, i.e.">size()</a> only changes if <a class="el" href="classgul17_1_1SlidingBuffer.html#a5ae2048533f57795936580303783415d" title="Empty the buffer.">clear()</a>, <a class="el" href="classgul17_1_1SlidingBuffer.html#ad2dbfba3ae83a63a8ed9435658b0331e" title="Remove the first element from the buffer.">pop_front()</a>, or <a class="el" href="classgul17_1_1SlidingBuffer.html#a80cc0a2d09ab6d3fb133a30159ab108d" title="Remove the last element from the buffer.">pop_back()</a> are used.</p>
<p>A typical application would be to analyze an incoming stream of elements in a finite impulse response filter.</p>
<p>This container uses an accompanying iterator class called <a class="el" href="classgul17_1_1SlidingBuffer_1_1SlidingBufferIterator.html" title="Iterator of the SlidingBuffer container.">SlidingBufferIterator</a>. See <a class="el" href="classgul17_1_1SlidingBufferExposed.html" title="A std::variant of SlidingBuffer that exposes the underlying container through its iterator interface.">SlidingBufferExposed</a> for a std::variant with a different (more performant) iterator interface.</p>
<p>Iterator invalidation is specified at <a class="el" href="classgul17_1_1SlidingBuffer_1_1SlidingBufferIterator.html" title="Iterator of the SlidingBuffer container.">SlidingBufferIterator</a>.</p>
<div class="fragment"><div class="line">Member types:</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a>                  Type of the elements</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#a2afa4761a0869df6d0cfb3498c1bc930">container_type</a>              Type of the underlying container (i.e. std::array&lt;value_type, ..&gt;)</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>                   Unsigned integer type (usually std::size_t)</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#abeada5bb621eac9d4de9f9e95b8f47df">difference_type</a>             Signed integer type (usually std::ptrdiff_t)</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">reference</a>                   <a class="code" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a>&amp;</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#a415c549451366b97fcd17a4fece23957">const_reference</a>             <a class="code" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a> <span class="keyword">const</span>&amp;</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#ad286acdff9b2d52225bacba705a6d001">pointer</a>                     <a class="code" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a>*</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#a4e6847f45f832decefe2379f9550f76a">const_pointer</a>               <a class="code" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a> <span class="keyword">const</span>*</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a>                    SlidingBufferIterator</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#a7ac85e7b2e620ffa921abc23fb3abc68">const_iterator</a>              SlidingBufferIterator <span class="keyword">const</span></div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#a7036c8bfac0cbe4d12f21febc7e069c0">reverse_iterator</a>            SlidingBufferIterator</div>
<div class="line">  <a class="code" href="classgul17_1_1SlidingBuffer.html#ad7ce6fe5c09688914add7a4e011a2e9a">const_reverse_iterator</a>      SlidingBufferIterator <span class="keyword">const</span></div>
<div class="line"> </div>
<div class="line">Member functions:</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a3b4f2804392dc6e1c9c607d64d70b4a3">SlidingBuffer</a>     Constructor</div>
<div class="line">  Element access:</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a2dd0eeb815fc15462a54dfe0f5638c2d">push_back</a>         Insert an element <a class="code" href="classgul17_1_1SlidingBuffer.html#acbd994e0e9bd54ea39cd58120a99a721">at</a> the <a class="code" href="classgul17_1_1SlidingBuffer.html#a74bf22b1926adb341c3463a5a5640fd7">back</a> of the buffer</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a6b76a482abef03edeb5e419b3f0b9a37">push_front</a>        Insert an element <a class="code" href="classgul17_1_1SlidingBuffer.html#acbd994e0e9bd54ea39cd58120a99a721">at</a> the <a class="code" href="classgul17_1_1SlidingBuffer.html#a9f12d073f6eb2ae5709e0f31f0a2db6b">front</a> of the buffer</div>
<div class="line">    <span class="keyword">operator</span>[]        Access element by index, unchecked</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#acbd994e0e9bd54ea39cd58120a99a721">at</a>                Access element by index with bounds checking</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a9f12d073f6eb2ae5709e0f31f0a2db6b">front</a>             Access the foremost element (i.e. [0])</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a74bf22b1926adb341c3463a5a5640fd7">back</a>              Access the last element (i.e. [<a class="code" href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38">size</a>() - 1])</div>
<div class="line">  Iterators:</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a5feacc75b8e2672bfce722f9c7d5ec3d">begin</a>, <a class="code" href="classgul17_1_1SlidingBuffer.html#a6e57c13eb9fd53590ba1d7c60f3758df">cbegin</a>     Return an <a class="code" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a> to the first element of the container</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#ab2993ba19df341d7edf780293a64b828">end</a>, <a class="code" href="classgul17_1_1SlidingBuffer.html#a97c5b14aeb0694b201ea25b597c01158">cend</a>         Return an <a class="code" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a> to the element following the last element of the container</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a4fc0d4e8c9e022a75daaef114fff12c0">rbegin</a>, <a class="code" href="classgul17_1_1SlidingBuffer.html#a89e3d91b08a494edba1ccf1c0989f93c">crbegin</a>   Return an <a class="code" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a> to the first element of the reversed container</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a48733b4ec8753acddb4155596c6b5acc">rend</a>, <a class="code" href="classgul17_1_1SlidingBuffer.html#a1adadc08b08c29d5a36a8ea1a3b8d792">crend</a>       Return an <a class="code" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a> to the element following the last element of the reversed container</div>
<div class="line">  Capacity:</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38">size</a>              Return number of used elements</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a6e70351dc3956330ee3da795d84852f0">capacity</a>          Return <a class="code" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a">maximum</a> number of elements</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#acad96b773ad51142cb20726fc421e861">filled</a>            Check whether the buffer is completely <a class="code" href="classgul17_1_1SlidingBuffer.html#acad96b773ad51142cb20726fc421e861">filled</a></div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a9f589fae3efeb5a851f41a4151576965">empty</a>             Check whether the buffer is <a class="code" href="classgul17_1_1SlidingBuffer.html#a9f589fae3efeb5a851f41a4151576965">empty</a></div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89">resize</a>            Change the <a class="code" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a">maximum</a> number of elements (only if fixed_size==0)</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#ab7d5f6ad9719bdf7adf6fe095cb30e2b">reserve</a>           Change the <a class="code" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a">maximum</a> number of elements (only if fixed_size==0)</div>
<div class="line">  Modifiers:</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a5ae2048533f57795936580303783415d">clear</a>             Empty the buffer</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#a80cc0a2d09ab6d3fb133a30159ab108d">pop_back</a>          Drop the last element</div>
<div class="line">    <a class="code" href="classgul17_1_1SlidingBuffer.html#ad2dbfba3ae83a63a8ed9435658b0331e">pop_front</a>         Drop the foremost element</div>
<div class="line"> </div>
<div class="line">Non-member functions:</div>
<div class="line">  operator&lt;&lt;          Dump the raw data of the buffer to an ostream</div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a1adadc08b08c29d5a36a8ea1a3b8d792"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a1adadc08b08c29d5a36a8ea1a3b8d792">gul17::SlidingBuffer::crend</a></div><div class="ttdeci">auto crend() const noexcept -&gt; const_reverse_iterator</div><div class="ttdoc">Return a read-only iterator to the element following the last element of the reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:935</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a2afa4761a0869df6d0cfb3498c1bc930"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a2afa4761a0869df6d0cfb3498c1bc930">gul17::SlidingBuffer::container_type</a></div><div class="ttdeci">Container container_type</div><div class="ttdoc">Type of the underlying container (e.g. std::array&lt;value_type, ..&gt;)</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:186</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a2dd0eeb815fc15462a54dfe0f5638c2d"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a2dd0eeb815fc15462a54dfe0f5638c2d">gul17::SlidingBuffer::push_back</a></div><div class="ttdeci">auto push_back(const value_type &amp;in) -&gt; void</div><div class="ttdoc">Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:306</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a3b4f2804392dc6e1c9c607d64d70b4a3"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a3b4f2804392dc6e1c9c607d64d70b4a3">gul17::SlidingBuffer::SlidingBuffer</a></div><div class="ttdeci">SlidingBuffer()=default</div><div class="ttdoc">Construct an empty sliding buffer.</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a415c549451366b97fcd17a4fece23957"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a415c549451366b97fcd17a4fece23957">gul17::SlidingBuffer::const_reference</a></div><div class="ttdeci">typename Container::const_reference const_reference</div><div class="ttdoc">Reference to a constant element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:196</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a48733b4ec8753acddb4155596c6b5acc"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a48733b4ec8753acddb4155596c6b5acc">gul17::SlidingBuffer::rend</a></div><div class="ttdeci">auto rend() noexcept -&gt; reverse_iterator</div><div class="ttdoc">Return an iterator to the element following the last element of the reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:891</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a4e6847f45f832decefe2379f9550f76a"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a4e6847f45f832decefe2379f9550f76a">gul17::SlidingBuffer::const_pointer</a></div><div class="ttdeci">typename Container::const_pointer const_pointer</div><div class="ttdoc">Pointer to a constant element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:200</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a4fc0d4e8c9e022a75daaef114fff12c0"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a4fc0d4e8c9e022a75daaef114fff12c0">gul17::SlidingBuffer::rbegin</a></div><div class="ttdeci">auto rbegin() noexcept -&gt; reverse_iterator</div><div class="ttdoc">Return an iterator to the first element of the reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:862</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a5ae2048533f57795936580303783415d"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a5ae2048533f57795936580303783415d">gul17::SlidingBuffer::clear</a></div><div class="ttdeci">auto clear() -&gt; void</div><div class="ttdoc">Empty the buffer.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:526</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a5e64c3e8e501717e2caca419b235fa89"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89">gul17::SlidingBuffer::resize</a></div><div class="ttdeci">auto resize(size_type new_capacity, ShrinkBehavior shrink_behavior=ShrinkBehavior::keep_front_elements) -&gt; void</div><div class="ttdoc">Resize the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:555</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a5feacc75b8e2672bfce722f9c7d5ec3d"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a5feacc75b8e2672bfce722f9c7d5ec3d">gul17::SlidingBuffer::begin</a></div><div class="ttdeci">auto begin() noexcept -&gt; iterator</div><div class="ttdoc">Return an iterator to the first element of the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:846</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a6b76a482abef03edeb5e419b3f0b9a37"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a6b76a482abef03edeb5e419b3f0b9a37">gul17::SlidingBuffer::push_front</a></div><div class="ttdeci">auto push_front(const value_type &amp;in) -&gt; void</div><div class="ttdoc">Insert one element at the front of the buffer; if it is full, an element at the back is dropped to ma...</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:344</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a6e57c13eb9fd53590ba1d7c60f3758df"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a6e57c13eb9fd53590ba1d7c60f3758df">gul17::SlidingBuffer::cbegin</a></div><div class="ttdeci">auto cbegin() const noexcept -&gt; const_iterator</div><div class="ttdoc">Return a read-only iterator to the first element of the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:901</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a6e70351dc3956330ee3da795d84852f0"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a6e70351dc3956330ee3da795d84852f0">gul17::SlidingBuffer::capacity</a></div><div class="ttdeci">constexpr auto capacity() const noexcept -&gt; size_type</div><div class="ttdoc">Return the maximum possible number of elements in the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:501</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a7036c8bfac0cbe4d12f21febc7e069c0"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a7036c8bfac0cbe4d12f21febc7e069c0">gul17::SlidingBuffer::reverse_iterator</a></div><div class="ttdeci">std::reverse_iterator&lt; iterator &gt; reverse_iterator</div><div class="ttdoc">Iterator to an element in reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:206</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a7270e17aa3a8bb67d1358b717f25af9b"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">gul17::SlidingBuffer::reference</a></div><div class="ttdeci">typename Container::reference reference</div><div class="ttdoc">Reference to an element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:194</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a74bf22b1926adb341c3463a5a5640fd7"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a74bf22b1926adb341c3463a5a5640fd7">gul17::SlidingBuffer::back</a></div><div class="ttdeci">auto back() noexcept -&gt; reference</div><div class="ttdoc">Return the backmost element (the one with the highest valid index).</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:457</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a7ac85e7b2e620ffa921abc23fb3abc68"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a7ac85e7b2e620ffa921abc23fb3abc68">gul17::SlidingBuffer::const_iterator</a></div><div class="ttdeci">SlidingBufferIterator&lt; SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt; const  * &gt; const_iterator</div><div class="ttdoc">Iterator to a const element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:204</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a80cc0a2d09ab6d3fb133a30159ab108d"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a80cc0a2d09ab6d3fb133a30159ab108d">gul17::SlidingBuffer::pop_back</a></div><div class="ttdeci">auto pop_back() -&gt; void</div><div class="ttdoc">Remove the last element from the buffer.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:270</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a81654a64671df1d14fbb90402e961d38"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38">gul17::SlidingBuffer::size</a></div><div class="ttdeci">auto size() const noexcept -&gt; size_type</div><div class="ttdoc">Return the number of elements in the container, i.e.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:483</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a853fa9b18063f79e56550b0d8a4122ae"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">gul17::SlidingBuffer::iterator</a></div><div class="ttdeci">SlidingBufferIterator&lt; SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt; * &gt; iterator</div><div class="ttdoc">Iterator to an element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:202</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a89e3d91b08a494edba1ccf1c0989f93c"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a89e3d91b08a494edba1ccf1c0989f93c">gul17::SlidingBuffer::crbegin</a></div><div class="ttdeci">auto crbegin() const noexcept -&gt; const_reverse_iterator</div><div class="ttdoc">Return a read-only iterator to the first element of the reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:911</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a8c52abaadd4d2cca55f508904a2892b8"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">gul17::SlidingBuffer::size_type</a></div><div class="ttdeci">typename Container::size_type size_type</div><div class="ttdoc">Unsigned integer type (usually std::size_t)</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:190</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a97c5b14aeb0694b201ea25b597c01158"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a97c5b14aeb0694b201ea25b597c01158">gul17::SlidingBuffer::cend</a></div><div class="ttdeci">auto cend() const noexcept -&gt; const_iterator</div><div class="ttdoc">Return a read-only iterator to the element following the last element of the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:923</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a9f12d073f6eb2ae5709e0f31f0a2db6b"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a9f12d073f6eb2ae5709e0f31f0a2db6b">gul17::SlidingBuffer::front</a></div><div class="ttdeci">auto front() noexcept -&gt; reference</div><div class="ttdoc">Return the foremost element (the one with index 0).</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:438</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_a9f589fae3efeb5a851f41a4151576965"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#a9f589fae3efeb5a851f41a4151576965">gul17::SlidingBuffer::empty</a></div><div class="ttdeci">auto empty() const noexcept -&gt; bool</div><div class="ttdoc">Check if the buffer contains no elements, i.e.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:578</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_ab0b856524eed935da3eff7dba15f3fb8"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">gul17::SlidingBuffer::value_type</a></div><div class="ttdeci">ElementT value_type</div><div class="ttdoc">Type of the elements in the underlying container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:188</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_ab2993ba19df341d7edf780293a64b828"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#ab2993ba19df341d7edf780293a64b828">gul17::SlidingBuffer::end</a></div><div class="ttdeci">auto end() noexcept -&gt; iterator</div><div class="ttdoc">Return an iterator to the element following the last element of the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:873</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_ab7d5f6ad9719bdf7adf6fe095cb30e2b"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#ab7d5f6ad9719bdf7adf6fe095cb30e2b">gul17::SlidingBuffer::reserve</a></div><div class="ttdeci">auto reserve(size_type size, ShrinkBehavior shrink_behavior=ShrinkBehavior::keep_front_elements) -&gt; void</div><div class="ttdoc">Resize the container (identical to resize()).</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:566</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_abeada5bb621eac9d4de9f9e95b8f47df"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#abeada5bb621eac9d4de9f9e95b8f47df">gul17::SlidingBuffer::difference_type</a></div><div class="ttdeci">typename Container::difference_type difference_type</div><div class="ttdoc">Signed integer type (usually std::ptrdiff_t)</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:192</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_acad96b773ad51142cb20726fc421e861"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#acad96b773ad51142cb20726fc421e861">gul17::SlidingBuffer::filled</a></div><div class="ttdeci">auto filled() const noexcept -&gt; bool</div><div class="ttdoc">Return true if the buffer is completely filled with elements.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:514</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_acbd994e0e9bd54ea39cd58120a99a721"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#acbd994e0e9bd54ea39cd58120a99a721">gul17::SlidingBuffer::at</a></div><div class="ttdeci">auto at(const size_type idx) noexcept(false) -&gt; reference</div><div class="ttdoc">Access an element in the buffer by index with bounds checking.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:409</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_ad286acdff9b2d52225bacba705a6d001"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#ad286acdff9b2d52225bacba705a6d001">gul17::SlidingBuffer::pointer</a></div><div class="ttdeci">typename Container::pointer pointer</div><div class="ttdoc">Pointer to an element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:198</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_ad2dbfba3ae83a63a8ed9435658b0331e"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#ad2dbfba3ae83a63a8ed9435658b0331e">gul17::SlidingBuffer::pop_front</a></div><div class="ttdeci">auto pop_front() -&gt; void</div><div class="ttdoc">Remove the first element from the buffer.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:287</div></div>
<div class="ttc" id="aclassgul17_1_1SlidingBuffer_html_ad7ce6fe5c09688914add7a4e011a2e9a"><div class="ttname"><a href="classgul17_1_1SlidingBuffer.html#ad7ce6fe5c09688914add7a4e011a2e9a">gul17::SlidingBuffer::const_reverse_iterator</a></div><div class="ttdeci">std::reverse_iterator&lt; const_iterator &gt; const_reverse_iterator</div><div class="ttdoc">Iterator to a const element in reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:208</div></div>
<div class="ttc" id="agroup__statistics__h_html_gadaf7c055a3321c2879bbb3747421e53a"><div class="ttname"><a href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a">gul17::maximum</a></div><div class="ttdeci">auto maximum(ContainerT const &amp;container, Accessor accessor=ElementAccessor&lt; ElementT &gt;()) -&gt; DataT</div><div class="ttdoc">Return the maximum element value in a container.</div><div class="ttdef"><b>Definition:</b> statistics.h:314</div></div>
</div><!-- fragment --><p>The sliding buffer can be instantiated in two slightly different versions:</p><ul>
<li>If the size is known at compile time, it can be specified as the <b><code>fixed_capacity</code></b> template parameter. The elements are stored within the sliding buffer as in a std::array.</li>
<li>If a flexible capacity is desired, <b><code>fixed_capacity</code></b> can be omitted. It defaults to zero, and space for elements can subsequently be allocated dynamically as in a std::vector. You need to use a constructor that sets a certain capacity or set the capacity afterwards with <a class="el" href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89" title="Resize the container.">resize()</a>. As long as the capacity is zero, the buffer is unusable and most operations result in undefined behavior.</li>
</ul>
<p><b><code>ElementT</code></b> must be default constructible.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>Type of elements in the buffer </td></tr>
    <tr><td class="paramname">fixed_capacity</td><td>Maximum number of elements in the buffer (capacity), zero if unspecified/dynamic </td></tr>
    <tr><td class="paramname">Container</td><td>Type of the underlying container, usually not specified </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;<a class="el" href="SlidingBuffer_8h_source.html">SlidingBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator of the <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> container.  <a href="classgul17_1_1SlidingBuffer_1_1SlidingBufferIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2afa4761a0869df6d0cfb3498c1bc930"><td class="memItemLeft" align="right" valign="top"><a id="a2afa4761a0869df6d0cfb3498c1bc930"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a2afa4761a0869df6d0cfb3498c1bc930">container_type</a> = Container</td></tr>
<tr class="memdesc:a2afa4761a0869df6d0cfb3498c1bc930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the underlying container (e.g. std::array&lt;value_type, ..&gt;) <br /></td></tr>
<tr class="separator:a2afa4761a0869df6d0cfb3498c1bc930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b856524eed935da3eff7dba15f3fb8"><td class="memItemLeft" align="right" valign="top"><a id="ab0b856524eed935da3eff7dba15f3fb8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a> = ElementT</td></tr>
<tr class="memdesc:ab0b856524eed935da3eff7dba15f3fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the elements in the underlying container. <br /></td></tr>
<tr class="separator:ab0b856524eed935da3eff7dba15f3fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c52abaadd4d2cca55f508904a2892b8"><td class="memItemLeft" align="right" valign="top"><a id="a8c52abaadd4d2cca55f508904a2892b8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a> = typename Container::size_type</td></tr>
<tr class="memdesc:a8c52abaadd4d2cca55f508904a2892b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type (usually std::size_t) <br /></td></tr>
<tr class="separator:a8c52abaadd4d2cca55f508904a2892b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeada5bb621eac9d4de9f9e95b8f47df"><td class="memItemLeft" align="right" valign="top"><a id="abeada5bb621eac9d4de9f9e95b8f47df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#abeada5bb621eac9d4de9f9e95b8f47df">difference_type</a> = typename Container::difference_type</td></tr>
<tr class="memdesc:abeada5bb621eac9d4de9f9e95b8f47df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type (usually std::ptrdiff_t) <br /></td></tr>
<tr class="separator:abeada5bb621eac9d4de9f9e95b8f47df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7270e17aa3a8bb67d1358b717f25af9b"><td class="memItemLeft" align="right" valign="top"><a id="a7270e17aa3a8bb67d1358b717f25af9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">reference</a> = typename Container::reference</td></tr>
<tr class="memdesc:a7270e17aa3a8bb67d1358b717f25af9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to an element. <br /></td></tr>
<tr class="separator:a7270e17aa3a8bb67d1358b717f25af9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415c549451366b97fcd17a4fece23957"><td class="memItemLeft" align="right" valign="top"><a id="a415c549451366b97fcd17a4fece23957"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a415c549451366b97fcd17a4fece23957">const_reference</a> = typename Container::const_reference</td></tr>
<tr class="memdesc:a415c549451366b97fcd17a4fece23957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant element. <br /></td></tr>
<tr class="separator:a415c549451366b97fcd17a4fece23957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad286acdff9b2d52225bacba705a6d001"><td class="memItemLeft" align="right" valign="top"><a id="ad286acdff9b2d52225bacba705a6d001"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#ad286acdff9b2d52225bacba705a6d001">pointer</a> = typename Container::pointer</td></tr>
<tr class="memdesc:ad286acdff9b2d52225bacba705a6d001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to an element. <br /></td></tr>
<tr class="separator:ad286acdff9b2d52225bacba705a6d001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6847f45f832decefe2379f9550f76a"><td class="memItemLeft" align="right" valign="top"><a id="a4e6847f45f832decefe2379f9550f76a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a4e6847f45f832decefe2379f9550f76a">const_pointer</a> = typename Container::const_pointer</td></tr>
<tr class="memdesc:a4e6847f45f832decefe2379f9550f76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant element. <br /></td></tr>
<tr class="separator:a4e6847f45f832decefe2379f9550f76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853fa9b18063f79e56550b0d8a4122ae"><td class="memItemLeft" align="right" valign="top"><a id="a853fa9b18063f79e56550b0d8a4122ae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a> = <a class="el" href="classgul17_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a>&lt; <a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt; * &gt;</td></tr>
<tr class="memdesc:a853fa9b18063f79e56550b0d8a4122ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to an element. <br /></td></tr>
<tr class="separator:a853fa9b18063f79e56550b0d8a4122ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac85e7b2e620ffa921abc23fb3abc68"><td class="memItemLeft" align="right" valign="top"><a id="a7ac85e7b2e620ffa921abc23fb3abc68"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a7ac85e7b2e620ffa921abc23fb3abc68">const_iterator</a> = <a class="el" href="classgul17_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a>&lt; <a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt; const  * &gt;</td></tr>
<tr class="memdesc:a7ac85e7b2e620ffa921abc23fb3abc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to a const element. <br /></td></tr>
<tr class="separator:a7ac85e7b2e620ffa921abc23fb3abc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7036c8bfac0cbe4d12f21febc7e069c0"><td class="memItemLeft" align="right" valign="top"><a id="a7036c8bfac0cbe4d12f21febc7e069c0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a7036c8bfac0cbe4d12f21febc7e069c0">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a> &gt;</td></tr>
<tr class="memdesc:a7036c8bfac0cbe4d12f21febc7e069c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to an element in reversed container. <br /></td></tr>
<tr class="separator:a7036c8bfac0cbe4d12f21febc7e069c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ce6fe5c09688914add7a4e011a2e9a"><td class="memItemLeft" align="right" valign="top"><a id="ad7ce6fe5c09688914add7a4e011a2e9a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#ad7ce6fe5c09688914add7a4e011a2e9a">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7ac85e7b2e620ffa921abc23fb3abc68">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:ad7ce6fe5c09688914add7a4e011a2e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to a const element in reversed container. <br /></td></tr>
<tr class="separator:ad7ce6fe5c09688914add7a4e011a2e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b4f2804392dc6e1c9c607d64d70b4a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a3b4f2804392dc6e1c9c607d64d70b4a3">SlidingBuffer</a> ()=default</td></tr>
<tr class="memdesc:a3b4f2804392dc6e1c9c607d64d70b4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty sliding buffer.  <a href="classgul17_1_1SlidingBuffer.html#a3b4f2804392dc6e1c9c607d64d70b4a3">More...</a><br /></td></tr>
<tr class="separator:a3b4f2804392dc6e1c9c607d64d70b4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac243f920e33c1220d06a5cb1a6dfbc15"><td class="memItemLeft" align="right" valign="top"><a id="ac243f920e33c1220d06a5cb1a6dfbc15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#ac243f920e33c1220d06a5cb1a6dfbc15">SlidingBuffer</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a> const &amp;)=default</td></tr>
<tr class="memdesc:ac243f920e33c1220d06a5cb1a6dfbc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor. <br /></td></tr>
<tr class="separator:ac243f920e33c1220d06a5cb1a6dfbc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3975a758913339b377fd835c3d877e"><td class="memItemLeft" align="right" valign="top"><a id="a2e3975a758913339b377fd835c3d877e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a2e3975a758913339b377fd835c3d877e">SlidingBuffer</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a> &amp;&amp;) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a2afa4761a0869df6d0cfb3498c1bc930">container_type</a> &gt;::value)=default</td></tr>
<tr class="memdesc:a2e3975a758913339b377fd835c3d877e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor. <br /></td></tr>
<tr class="separator:a2e3975a758913339b377fd835c3d877e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad218d10eca4ca3a4ddce08992e8281ac"><td class="memItemLeft" align="right" valign="top"><a id="ad218d10eca4ca3a4ddce08992e8281ac"></a>
<a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#ad218d10eca4ca3a4ddce08992e8281ac">operator=</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a> const &amp;)=default</td></tr>
<tr class="memdesc:ad218d10eca4ca3a4ddce08992e8281ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator. <br /></td></tr>
<tr class="separator:ad218d10eca4ca3a4ddce08992e8281ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43f7c6e71a7b0b6e3fb0125a6594f63"><td class="memItemLeft" align="right" valign="top"><a id="ab43f7c6e71a7b0b6e3fb0125a6594f63"></a>
<a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#ab43f7c6e71a7b0b6e3fb0125a6594f63">operator=</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a> &amp;&amp;) noexcept(std::is_nothrow_move_assignable&lt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a2afa4761a0869df6d0cfb3498c1bc930">container_type</a> &gt;::value)=default</td></tr>
<tr class="memdesc:ab43f7c6e71a7b0b6e3fb0125a6594f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment operator. <br /></td></tr>
<tr class="separator:ab43f7c6e71a7b0b6e3fb0125a6594f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac475a0cdc52171fbeb99131e6446475"><td class="memItemLeft" align="right" valign="top"><a id="aac475a0cdc52171fbeb99131e6446475"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#aac475a0cdc52171fbeb99131e6446475">~SlidingBuffer</a> ()=default</td></tr>
<tr class="memdesc:aac475a0cdc52171fbeb99131e6446475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor. <br /></td></tr>
<tr class="separator:aac475a0cdc52171fbeb99131e6446475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c91bd9b08b5bd1d3e92b87e1bd24c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a70c91bd9b08b5bd1d3e92b87e1bd24c4">SlidingBuffer</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a> count)</td></tr>
<tr class="memdesc:a70c91bd9b08b5bd1d3e92b87e1bd24c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.Only available for sliding buffers based on std::vector.  <a href="classgul17_1_1SlidingBuffer.html#a70c91bd9b08b5bd1d3e92b87e1bd24c4">More...</a><br /></td></tr>
<tr class="separator:a70c91bd9b08b5bd1d3e92b87e1bd24c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cc0a2d09ab6d3fb133a30159ab108d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a80cc0a2d09ab6d3fb133a30159ab108d">pop_back</a> () -&gt; void</td></tr>
<tr class="memdesc:a80cc0a2d09ab6d3fb133a30159ab108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element from the buffer.  <a href="classgul17_1_1SlidingBuffer.html#a80cc0a2d09ab6d3fb133a30159ab108d">More...</a><br /></td></tr>
<tr class="separator:a80cc0a2d09ab6d3fb133a30159ab108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dbfba3ae83a63a8ed9435658b0331e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#ad2dbfba3ae83a63a8ed9435658b0331e">pop_front</a> () -&gt; void</td></tr>
<tr class="memdesc:ad2dbfba3ae83a63a8ed9435658b0331e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first element from the buffer.  <a href="classgul17_1_1SlidingBuffer.html#ad2dbfba3ae83a63a8ed9435658b0331e">More...</a><br /></td></tr>
<tr class="separator:ad2dbfba3ae83a63a8ed9435658b0331e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd0eeb815fc15462a54dfe0f5638c2d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a2dd0eeb815fc15462a54dfe0f5638c2d">push_back</a> (const <a class="el" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a> &amp;in) -&gt; void</td></tr>
<tr class="memdesc:a2dd0eeb815fc15462a54dfe0f5638c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element at the end of the buffer; if it is full, an element at the front is dropped to make room.  <a href="classgul17_1_1SlidingBuffer.html#a2dd0eeb815fc15462a54dfe0f5638c2d">More...</a><br /></td></tr>
<tr class="separator:a2dd0eeb815fc15462a54dfe0f5638c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76e1dbc36f7c5bb67780fe3333b5902"><td class="memItemLeft" align="right" valign="top"><a id="af76e1dbc36f7c5bb67780fe3333b5902"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#af76e1dbc36f7c5bb67780fe3333b5902">push_back</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a> &amp;&amp;in) -&gt; void</td></tr>
<tr class="memdesc:af76e1dbc36f7c5bb67780fe3333b5902"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:af76e1dbc36f7c5bb67780fe3333b5902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b76a482abef03edeb5e419b3f0b9a37"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a6b76a482abef03edeb5e419b3f0b9a37">push_front</a> (const <a class="el" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a> &amp;in) -&gt; void</td></tr>
<tr class="memdesc:a6b76a482abef03edeb5e419b3f0b9a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element at the front of the buffer; if it is full, an element at the back is dropped to make room.  <a href="classgul17_1_1SlidingBuffer.html#a6b76a482abef03edeb5e419b3f0b9a37">More...</a><br /></td></tr>
<tr class="separator:a6b76a482abef03edeb5e419b3f0b9a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04bcd995a36a0aa06717168dae92a97"><td class="memItemLeft" align="right" valign="top"><a id="aa04bcd995a36a0aa06717168dae92a97"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#aa04bcd995a36a0aa06717168dae92a97">push_front</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a> &amp;&amp;in) -&gt; void</td></tr>
<tr class="memdesc:aa04bcd995a36a0aa06717168dae92a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aa04bcd995a36a0aa06717168dae92a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e33ffc6744925d4a81990f3d384c52e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a3e33ffc6744925d4a81990f3d384c52e">operator[]</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a> idx) noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">reference</a></td></tr>
<tr class="memdesc:a3e33ffc6744925d4a81990f3d384c52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element in the buffer by index without bounds checking.  <a href="classgul17_1_1SlidingBuffer.html#a3e33ffc6744925d4a81990f3d384c52e">More...</a><br /></td></tr>
<tr class="separator:a3e33ffc6744925d4a81990f3d384c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb9d1fdb0f6e1b7bde2541fe854ce7c"><td class="memItemLeft" align="right" valign="top"><a id="abfb9d1fdb0f6e1b7bde2541fe854ce7c"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#abfb9d1fdb0f6e1b7bde2541fe854ce7c">operator[]</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a> idx) const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a415c549451366b97fcd17a4fece23957">const_reference</a></td></tr>
<tr class="memdesc:abfb9d1fdb0f6e1b7bde2541fe854ce7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:abfb9d1fdb0f6e1b7bde2541fe854ce7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd994e0e9bd54ea39cd58120a99a721"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#acbd994e0e9bd54ea39cd58120a99a721">at</a> (const <a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a> idx) noexcept(false) -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">reference</a></td></tr>
<tr class="memdesc:acbd994e0e9bd54ea39cd58120a99a721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element in the buffer by index with bounds checking.  <a href="classgul17_1_1SlidingBuffer.html#acbd994e0e9bd54ea39cd58120a99a721">More...</a><br /></td></tr>
<tr class="separator:acbd994e0e9bd54ea39cd58120a99a721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf06480fcac94ec2270b26b30cbbe73d"><td class="memItemLeft" align="right" valign="top"><a id="aaf06480fcac94ec2270b26b30cbbe73d"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#aaf06480fcac94ec2270b26b30cbbe73d">at</a> (const <a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a> idx) const noexcept(false) -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a415c549451366b97fcd17a4fece23957">const_reference</a></td></tr>
<tr class="memdesc:aaf06480fcac94ec2270b26b30cbbe73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aaf06480fcac94ec2270b26b30cbbe73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f12d073f6eb2ae5709e0f31f0a2db6b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a9f12d073f6eb2ae5709e0f31f0a2db6b">front</a> () noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">reference</a></td></tr>
<tr class="memdesc:a9f12d073f6eb2ae5709e0f31f0a2db6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the foremost element (the one with index 0).  <a href="classgul17_1_1SlidingBuffer.html#a9f12d073f6eb2ae5709e0f31f0a2db6b">More...</a><br /></td></tr>
<tr class="separator:a9f12d073f6eb2ae5709e0f31f0a2db6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48fd68007b7645a10dee6867d39d927"><td class="memItemLeft" align="right" valign="top"><a id="af48fd68007b7645a10dee6867d39d927"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#af48fd68007b7645a10dee6867d39d927">front</a> () const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a415c549451366b97fcd17a4fece23957">const_reference</a></td></tr>
<tr class="memdesc:af48fd68007b7645a10dee6867d39d927"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:af48fd68007b7645a10dee6867d39d927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bf22b1926adb341c3463a5a5640fd7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a74bf22b1926adb341c3463a5a5640fd7">back</a> () noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">reference</a></td></tr>
<tr class="memdesc:a74bf22b1926adb341c3463a5a5640fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the backmost element (the one with the highest valid index).  <a href="classgul17_1_1SlidingBuffer.html#a74bf22b1926adb341c3463a5a5640fd7">More...</a><br /></td></tr>
<tr class="separator:a74bf22b1926adb341c3463a5a5640fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e2bf71de2a3131110afd92bf3a077d"><td class="memItemLeft" align="right" valign="top"><a id="a01e2bf71de2a3131110afd92bf3a077d"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a01e2bf71de2a3131110afd92bf3a077d">back</a> () const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a415c549451366b97fcd17a4fece23957">const_reference</a></td></tr>
<tr class="memdesc:a01e2bf71de2a3131110afd92bf3a077d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a01e2bf71de2a3131110afd92bf3a077d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81654a64671df1d14fbb90402e961d38"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38">size</a> () const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a></td></tr>
<tr class="memdesc:a81654a64671df1d14fbb90402e961d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the container, i.e.  <a href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38">More...</a><br /></td></tr>
<tr class="separator:a81654a64671df1d14fbb90402e961d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e70351dc3956330ee3da795d84852f0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a6e70351dc3956330ee3da795d84852f0">capacity</a> () const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a></td></tr>
<tr class="memdesc:a6e70351dc3956330ee3da795d84852f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum possible number of elements in the container.  <a href="classgul17_1_1SlidingBuffer.html#a6e70351dc3956330ee3da795d84852f0">More...</a><br /></td></tr>
<tr class="separator:a6e70351dc3956330ee3da795d84852f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad96b773ad51142cb20726fc421e861"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#acad96b773ad51142cb20726fc421e861">filled</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:acad96b773ad51142cb20726fc421e861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the buffer is completely filled with elements.  <a href="classgul17_1_1SlidingBuffer.html#acad96b773ad51142cb20726fc421e861">More...</a><br /></td></tr>
<tr class="separator:acad96b773ad51142cb20726fc421e861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae2048533f57795936580303783415d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a5ae2048533f57795936580303783415d">clear</a> () -&gt; void</td></tr>
<tr class="memdesc:a5ae2048533f57795936580303783415d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the buffer.  <a href="classgul17_1_1SlidingBuffer.html#a5ae2048533f57795936580303783415d">More...</a><br /></td></tr>
<tr class="separator:a5ae2048533f57795936580303783415d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e64c3e8e501717e2caca419b235fa89"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89">resize</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a> new_capacity, <a class="el" href="group__SlidingBuffer__h.html#gaff3db063c4badc364a003d2b53f59897">ShrinkBehavior</a> shrink_behavior=ShrinkBehavior::keep_front_elements) -&gt; void</td></tr>
<tr class="memdesc:a5e64c3e8e501717e2caca419b235fa89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container.  <a href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89">More...</a><br /></td></tr>
<tr class="separator:a5e64c3e8e501717e2caca419b235fa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d5f6ad9719bdf7adf6fe095cb30e2b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#ab7d5f6ad9719bdf7adf6fe095cb30e2b">reserve</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a> <a class="el" href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38">size</a>, <a class="el" href="group__SlidingBuffer__h.html#gaff3db063c4badc364a003d2b53f59897">ShrinkBehavior</a> shrink_behavior=ShrinkBehavior::keep_front_elements) -&gt; void</td></tr>
<tr class="memdesc:ab7d5f6ad9719bdf7adf6fe095cb30e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container (identical to <a class="el" href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89" title="Resize the container.">resize()</a>).  <a href="classgul17_1_1SlidingBuffer.html#ab7d5f6ad9719bdf7adf6fe095cb30e2b">More...</a><br /></td></tr>
<tr class="separator:ab7d5f6ad9719bdf7adf6fe095cb30e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f589fae3efeb5a851f41a4151576965"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a9f589fae3efeb5a851f41a4151576965">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a9f589fae3efeb5a851f41a4151576965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer contains no elements, i.e.  <a href="classgul17_1_1SlidingBuffer.html#a9f589fae3efeb5a851f41a4151576965">More...</a><br /></td></tr>
<tr class="separator:a9f589fae3efeb5a851f41a4151576965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b23b258909d239e5cabe9cb591949e"><td class="memItemLeft" align="right" valign="top">auto friend&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a65b23b258909d239e5cabe9cb591949e">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a>&lt; <a class="el" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a>, fixed_capacity, <a class="el" href="classgul17_1_1SlidingBuffer.html#a2afa4761a0869df6d0cfb3498c1bc930">container_type</a> &gt; &amp;buffer) -&gt; std::ostream &amp;</td></tr>
<tr class="memdesc:a65b23b258909d239e5cabe9cb591949e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump all buffer elements.  <a href="classgul17_1_1SlidingBuffer.html#a65b23b258909d239e5cabe9cb591949e">More...</a><br /></td></tr>
<tr class="separator:a65b23b258909d239e5cabe9cb591949e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5feacc75b8e2672bfce722f9c7d5ec3d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a5feacc75b8e2672bfce722f9c7d5ec3d">begin</a> () noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a></td></tr>
<tr class="memdesc:a5feacc75b8e2672bfce722f9c7d5ec3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first element of the container.  <a href="classgul17_1_1SlidingBuffer.html#a5feacc75b8e2672bfce722f9c7d5ec3d">More...</a><br /></td></tr>
<tr class="separator:a5feacc75b8e2672bfce722f9c7d5ec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb00f06ab11d29ad09f3fa95b2e10a0d"><td class="memItemLeft" align="right" valign="top"><a id="aeb00f06ab11d29ad09f3fa95b2e10a0d"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#aeb00f06ab11d29ad09f3fa95b2e10a0d">begin</a> () const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7ac85e7b2e620ffa921abc23fb3abc68">const_iterator</a></td></tr>
<tr class="memdesc:aeb00f06ab11d29ad09f3fa95b2e10a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aeb00f06ab11d29ad09f3fa95b2e10a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc0d4e8c9e022a75daaef114fff12c0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a4fc0d4e8c9e022a75daaef114fff12c0">rbegin</a> () noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7036c8bfac0cbe4d12f21febc7e069c0">reverse_iterator</a></td></tr>
<tr class="memdesc:a4fc0d4e8c9e022a75daaef114fff12c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first element of the reversed container.  <a href="classgul17_1_1SlidingBuffer.html#a4fc0d4e8c9e022a75daaef114fff12c0">More...</a><br /></td></tr>
<tr class="separator:a4fc0d4e8c9e022a75daaef114fff12c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2993ba19df341d7edf780293a64b828"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#ab2993ba19df341d7edf780293a64b828">end</a> () noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a></td></tr>
<tr class="memdesc:ab2993ba19df341d7edf780293a64b828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the element following the last element of the container.  <a href="classgul17_1_1SlidingBuffer.html#ab2993ba19df341d7edf780293a64b828">More...</a><br /></td></tr>
<tr class="separator:ab2993ba19df341d7edf780293a64b828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0582c902f343aee7ceb6d3e031d79181"><td class="memItemLeft" align="right" valign="top"><a id="a0582c902f343aee7ceb6d3e031d79181"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a0582c902f343aee7ceb6d3e031d79181">end</a> () const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7ac85e7b2e620ffa921abc23fb3abc68">const_iterator</a></td></tr>
<tr class="memdesc:a0582c902f343aee7ceb6d3e031d79181"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a0582c902f343aee7ceb6d3e031d79181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48733b4ec8753acddb4155596c6b5acc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a48733b4ec8753acddb4155596c6b5acc">rend</a> () noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7036c8bfac0cbe4d12f21febc7e069c0">reverse_iterator</a></td></tr>
<tr class="memdesc:a48733b4ec8753acddb4155596c6b5acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the element following the last element of the reversed container.  <a href="classgul17_1_1SlidingBuffer.html#a48733b4ec8753acddb4155596c6b5acc">More...</a><br /></td></tr>
<tr class="separator:a48733b4ec8753acddb4155596c6b5acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e57c13eb9fd53590ba1d7c60f3758df"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a6e57c13eb9fd53590ba1d7c60f3758df">cbegin</a> () const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7ac85e7b2e620ffa921abc23fb3abc68">const_iterator</a></td></tr>
<tr class="memdesc:a6e57c13eb9fd53590ba1d7c60f3758df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only iterator to the first element of the container.  <a href="classgul17_1_1SlidingBuffer.html#a6e57c13eb9fd53590ba1d7c60f3758df">More...</a><br /></td></tr>
<tr class="separator:a6e57c13eb9fd53590ba1d7c60f3758df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e3d91b08a494edba1ccf1c0989f93c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a89e3d91b08a494edba1ccf1c0989f93c">crbegin</a> () const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#ad7ce6fe5c09688914add7a4e011a2e9a">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a89e3d91b08a494edba1ccf1c0989f93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only iterator to the first element of the reversed container.  <a href="classgul17_1_1SlidingBuffer.html#a89e3d91b08a494edba1ccf1c0989f93c">More...</a><br /></td></tr>
<tr class="separator:a89e3d91b08a494edba1ccf1c0989f93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c5b14aeb0694b201ea25b597c01158"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a97c5b14aeb0694b201ea25b597c01158">cend</a> () const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7ac85e7b2e620ffa921abc23fb3abc68">const_iterator</a></td></tr>
<tr class="memdesc:a97c5b14aeb0694b201ea25b597c01158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only iterator to the element following the last element of the container.  <a href="classgul17_1_1SlidingBuffer.html#a97c5b14aeb0694b201ea25b597c01158">More...</a><br /></td></tr>
<tr class="separator:a97c5b14aeb0694b201ea25b597c01158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adadc08b08c29d5a36a8ea1a3b8d792"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a1adadc08b08c29d5a36a8ea1a3b8d792">crend</a> () const noexcept -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#ad7ce6fe5c09688914add7a4e011a2e9a">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a1adadc08b08c29d5a36a8ea1a3b8d792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only iterator to the element following the last element of the reversed container.  <a href="classgul17_1_1SlidingBuffer.html#a1adadc08b08c29d5a36a8ea1a3b8d792">More...</a><br /></td></tr>
<tr class="separator:a1adadc08b08c29d5a36a8ea1a3b8d792"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abd9319e5f6d3cea56d55659e985e79c5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#abd9319e5f6d3cea56d55659e985e79c5">change_capacity</a> (<a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a> new_capacity, <a class="el" href="group__SlidingBuffer__h.html#gaff3db063c4badc364a003d2b53f59897">ShrinkBehavior</a> shrink_behavior=ShrinkBehavior::keep_front_elements) -&gt; void</td></tr>
<tr class="memdesc:abd9319e5f6d3cea56d55659e985e79c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the underlying container's capacity.  <a href="classgul17_1_1SlidingBuffer.html#abd9319e5f6d3cea56d55659e985e79c5">More...</a><br /></td></tr>
<tr class="separator:abd9319e5f6d3cea56d55659e985e79c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a01d8ea8b5eebae0602e0b058cd91cb03"><td class="memItemLeft" align="right" valign="top"><a id="a01d8ea8b5eebae0602e0b058cd91cb03"></a>
<a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a01d8ea8b5eebae0602e0b058cd91cb03">idx_begin_</a> { 0u }</td></tr>
<tr class="memdesc:a01d8ea8b5eebae0602e0b058cd91cb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the first <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> element in the underlying container (the one retrieved by <a class="el" href="classgul17_1_1SlidingBuffer.html#a9f12d073f6eb2ae5709e0f31f0a2db6b" title="Return the foremost element (the one with index 0).">SlidingBuffer::front()</a>). <br /></td></tr>
<tr class="separator:a01d8ea8b5eebae0602e0b058cd91cb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099db8d990e8db7b1cccd08f10860f8f"><td class="memItemLeft" align="right" valign="top"><a id="a099db8d990e8db7b1cccd08f10860f8f"></a>
<a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a099db8d990e8db7b1cccd08f10860f8f">idx_end_</a> { 0u }</td></tr>
<tr class="memdesc:a099db8d990e8db7b1cccd08f10860f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index pointing to the element in the underlying container that will be written to by the next call to <a class="el" href="classgul17_1_1SlidingBuffer.html#a2dd0eeb815fc15462a54dfe0f5638c2d" title="Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...">push_back()</a>. <br /></td></tr>
<tr class="separator:a099db8d990e8db7b1cccd08f10860f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6820505f49e0748950f54e78d1f6bb76"><td class="memItemLeft" align="right" valign="top"><a id="a6820505f49e0748950f54e78d1f6bb76"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a6820505f49e0748950f54e78d1f6bb76">full_</a> { false }</td></tr>
<tr class="memdesc:a6820505f49e0748950f54e78d1f6bb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the buffer is completely filled with elements. <br /></td></tr>
<tr class="separator:a6820505f49e0748950f54e78d1f6bb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749b35547086c336f49200f3aec4d336"><td class="memItemLeft" align="right" valign="top"><a id="a749b35547086c336f49200f3aec4d336"></a>
Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html#a749b35547086c336f49200f3aec4d336">storage_</a> { }</td></tr>
<tr class="memdesc:a749b35547086c336f49200f3aec4d336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual data is stored here, the underlying container. <br /></td></tr>
<tr class="separator:a749b35547086c336f49200f3aec4d336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3b4f2804392dc6e1c9c607d64d70b4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4f2804392dc6e1c9c607d64d70b4a3">&#9670;&nbsp;</a></span>SlidingBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::<a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty sliding buffer. </p>
<p>The capacity of the buffer is given by the <b><code>fixed_capacity</code></b> template parameter. If that template argument is not zero, a std::array based <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> with that (unchangeable) capacity is created.</p>
<p>If the template argument is zero, a <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> based on std::vector with a capacity of zero elements is generated. Use the <a class="el" href="classgul17_1_1SlidingBuffer.html#a70c91bd9b08b5bd1d3e92b87e1bd24c4">SlidingBuffer(size_type)</a> constructor or call the <a class="el" href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89" title="Resize the container.">resize()</a> function afterwards to get a <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> based on std::vector with nonzero capacity. </p>

</div>
</div>
<a id="a70c91bd9b08b5bd1d3e92b87e1bd24c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c91bd9b08b5bd1d3e92b87e1bd24c4">&#9670;&nbsp;</a></span>SlidingBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::<a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.Only available for sliding buffers based on std::vector. </p>
<p>Constructs a sliding buffer with a specified capacity.</p>
<p>For std::array based sliding buffers the capacity is specified by the <b><code>fixed_capacity</code></b> template parameter. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acbd994e0e9bd54ea39cd58120a99a721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd994e0e9bd54ea39cd58120a99a721">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access an element in the buffer by index with bounds checking. </p>
<p>Index 0 is the foremost element, <code><a class="el" href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38" title="Return the number of elements in the container, i.e.">size()</a> - 1</code> the backmost one. Access to elements beyond the last one causes an exception to be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the element to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is thrown if <code>idx &gt;= <a class="el" href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38" title="Return the number of elements in the container, i.e.">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__cat__h.html#ga3443234f767248cd9ea020b0163b9f6b">gul17::cat()</a>.</p>

</div>
</div>
<a id="a74bf22b1926adb341c3463a5a5640fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bf22b1926adb341c3463a5a5640fd7">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the backmost element (the one with the highest valid index). </p>
<p>This call does not check if an element has ever been pushed into the buffer, so it might return a default-constructed element. In the case of a <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> with zero capacity, calling <a class="el" href="classgul17_1_1SlidingBuffer.html#a74bf22b1926adb341c3463a5a5640fd7" title="Return the backmost element (the one with the highest valid index).">back()</a> results in undefined behavior. </p>

</div>
</div>
<a id="a5feacc75b8e2672bfce722f9c7d5ec3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5feacc75b8e2672bfce722f9c7d5ec3d">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classgul17_1_1SlidingBuffer.html#ab2993ba19df341d7edf780293a64b828" title="Return an iterator to the element following the last element of the container.">end()</a>. </p>

</div>
</div>
<a id="a6e70351dc3956330ee3da795d84852f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e70351dc3956330ee3da795d84852f0">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum possible number of elements in the container. </p>
<p>If the underlying type is std::vector, its size is returned, not its capacity, because only the active elements (i.e. size) participate in the sliding buffer. </p>

</div>
</div>
<a id="a6e57c13eb9fd53590ba1d7c60f3758df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e57c13eb9fd53590ba1d7c60f3758df">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7ac85e7b2e620ffa921abc23fb3abc68">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classgul17_1_1SlidingBuffer.html#a97c5b14aeb0694b201ea25b597c01158" title="Return a read-only iterator to the element following the last element of the container.">cend()</a>. </p>

</div>
</div>
<a id="a97c5b14aeb0694b201ea25b597c01158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c5b14aeb0694b201ea25b597c01158">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7ac85e7b2e620ffa921abc23fb3abc68">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only iterator to the element following the last element of the container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="abd9319e5f6d3cea56d55659e985e79c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9319e5f6d3cea56d55659e985e79c5">&#9670;&nbsp;</a></span>change_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::change_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>&#160;</td>
          <td class="paramname"><em>new_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SlidingBuffer__h.html#gaff3db063c4badc364a003d2b53f59897">ShrinkBehavior</a>&#160;</td>
          <td class="paramname"><em>shrink_behavior</em> = <code>ShrinkBehavior::keep_front_elements</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the underlying container's capacity. </p>
<p>Only possible if the underlying container is a std::vector.</p>
<ul>
<li>Shrinking: The excess elements are dropped according to <b><code>shrink_behavior</code></b>.</li>
<li>Growing: The capacity changes, but the (used) size does not. It will grow gradually when elements are pushed, as in the startup phase.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_capacity</td><td>New capacity (maximum size) of the sliding buffer. </td></tr>
    <tr><td class="paramname">shrink_behavior</td><td>Specify the <a class="el" href="group__SlidingBuffer__h.html#gaff3db063c4badc364a003d2b53f59897">ShrinkBehavior</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89" title="Resize the container.">resize()</a> </dd></dl>

</div>
</div>
<a id="a5ae2048533f57795936580303783415d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae2048533f57795936580303783415d">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty the buffer. </p>
<p>(Almost) all iterators will be invalidated. See <a class="el" href="classgul17_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a>.</p>
<p>Its <a class="el" href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38" title="Return the number of elements in the container, i.e.">size()</a> will be zero afterwards. </p>

</div>
</div>
<a id="a89e3d91b08a494edba1ccf1c0989f93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e3d91b08a494edba1ccf1c0989f93c">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#ad7ce6fe5c09688914add7a4e011a2e9a">const_reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only iterator to the first element of the reversed container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classgul17_1_1SlidingBuffer.html#a97c5b14aeb0694b201ea25b597c01158" title="Return a read-only iterator to the element following the last element of the container.">cend()</a>. </p>

</div>
</div>
<a id="a1adadc08b08c29d5a36a8ea1a3b8d792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adadc08b08c29d5a36a8ea1a3b8d792">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#ad7ce6fe5c09688914add7a4e011a2e9a">const_reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only iterator to the element following the last element of the reversed container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a9f589fae3efeb5a851f41a4151576965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f589fae3efeb5a851f41a4151576965">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer contains no elements, i.e. </p>
<p>whether <a class="el" href="classgul17_1_1SlidingBuffer.html#a5feacc75b8e2672bfce722f9c7d5ec3d" title="Return an iterator to the first element of the container.">begin()</a> == <a class="el" href="classgul17_1_1SlidingBuffer.html#ab2993ba19df341d7edf780293a64b828" title="Return an iterator to the element following the last element of the container.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="ab2993ba19df341d7edf780293a64b828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2993ba19df341d7edf780293a64b828">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a853fa9b18063f79e56550b0d8a4122ae">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the element following the last element of the container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="acad96b773ad51142cb20726fc421e861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad96b773ad51142cb20726fc421e861">&#9670;&nbsp;</a></span>filled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::filled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the buffer is completely filled with elements. </p>
<p>If the buffer is used in filter contexts this means the filter is fully initialized and working.</p>
<p>If the buffer has zero capacity the value of <a class="el" href="classgul17_1_1SlidingBuffer.html#acad96b773ad51142cb20726fc421e861" title="Return true if the buffer is completely filled with elements.">filled()</a> is false. </p>

</div>
</div>
<a id="a9f12d073f6eb2ae5709e0f31f0a2db6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f12d073f6eb2ae5709e0f31f0a2db6b">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the foremost element (the one with index 0). </p>
<p>This call does not check if an element has ever been pushed into the buffer, so it might return a default-constructed element. In the case of a <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> with zero capacity, calling <a class="el" href="classgul17_1_1SlidingBuffer.html#a9f12d073f6eb2ae5709e0f31f0a2db6b" title="Return the foremost element (the one with index 0).">front()</a> results in undefined behavior. </p>

</div>
</div>
<a id="a65b23b258909d239e5cabe9cb591949e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b23b258909d239e5cabe9cb591949e">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto friend <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a>&lt; <a class="el" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a>, fixed_capacity, <a class="el" href="classgul17_1_1SlidingBuffer.html#a2afa4761a0869df6d0cfb3498c1bc930">container_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::ostream&amp;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump all buffer elements. </p>
<p>Shown on the left is <a class="el" href="classgul17_1_1SlidingBuffer.html#a9f12d073f6eb2ae5709e0f31f0a2db6b" title="Return the foremost element (the one with index 0).">front()</a>, on the right <a class="el" href="classgul17_1_1SlidingBuffer.html#a74bf22b1926adb341c3463a5a5640fd7" title="Return the backmost element (the one with the highest valid index).">back()</a>.</p>
<p>Needs the elements to be dump-able to an ostream. </p>

</div>
</div>
<a id="a3e33ffc6744925d4a81990f3d384c52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e33ffc6744925d4a81990f3d384c52e">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7270e17aa3a8bb67d1358b717f25af9b">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access an element in the buffer by index without bounds checking. </p>
<p>Index 0 is the foremost element, <code><a class="el" href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38" title="Return the number of elements in the container, i.e.">size()</a> - 1</code> the backmost one. Access to elements outside the capacity is not allowed and results in undefined behavior. Access to elements inside the capacity is always allowed; a default-constructed element is returned if <code>idx &gt;= <a class="el" href="classgul17_1_1SlidingBuffer.html#a81654a64671df1d14fbb90402e961d38" title="Return the number of elements in the container, i.e.">size()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested element. </dd></dl>

</div>
</div>
<a id="a80cc0a2d09ab6d3fb133a30159ab108d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cc0a2d09ab6d3fb133a30159ab108d">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last element from the buffer. </p>
<p>The <a class="el" href="classgul17_1_1SlidingBuffer.html#ab2993ba19df341d7edf780293a64b828" title="Return an iterator to the element following the last element of the container.">end()</a> iterator and any iterators to the last element are invalidated.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="classgul17_1_1SlidingBuffer.html#a80cc0a2d09ab6d3fb133a30159ab108d" title="Remove the last element from the buffer.">pop_back()</a> on an empty <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> results in undefined behavior.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.4 </dd></dl>

</div>
</div>
<a id="ad2dbfba3ae83a63a8ed9435658b0331e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dbfba3ae83a63a8ed9435658b0331e">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the first element from the buffer. </p>
<p>The <a class="el" href="classgul17_1_1SlidingBuffer.html#ab2993ba19df341d7edf780293a64b828" title="Return an iterator to the element following the last element of the container.">end()</a> iterator and any iterators to the last element are invalidated. All other iterators can still be dereferenced, but point to elements that have been shifted.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="classgul17_1_1SlidingBuffer.html#ad2dbfba3ae83a63a8ed9435658b0331e" title="Remove the first element from the buffer.">pop_front()</a> on an empty <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> results in undefined behavior.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.4 </dd></dl>

</div>
</div>
<a id="a2dd0eeb815fc15462a54dfe0f5638c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd0eeb815fc15462a54dfe0f5638c2d">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element at the end of the buffer; if it is full, an element at the front is dropped to make room. </p>
<p>At least some iterators can be invalidated. See <a class="el" href="classgul17_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a>.</p>
<p>Afterwards all iterators still point to the same logical element (i.e. element[n]).</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="classgul17_1_1SlidingBuffer.html#a2dd0eeb815fc15462a54dfe0f5638c2d" title="Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...">push_back()</a> on a <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> with zero capacity results in undefined behavior. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.3 </dd></dl>

</div>
</div>
<a id="a6b76a482abef03edeb5e419b3f0b9a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b76a482abef03edeb5e419b3f0b9a37">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul17_1_1SlidingBuffer.html#ab0b856524eed935da3eff7dba15f3fb8">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element at the front of the buffer; if it is full, an element at the back is dropped to make room. </p>
<p>At least some iterators can be invalidated. See <a class="el" href="classgul17_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a>.</p>
<p>Afterwards all iterators still point to the same logical element, while the contents of all logical elements is shifted.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="classgul17_1_1SlidingBuffer.html#a6b76a482abef03edeb5e419b3f0b9a37" title="Insert one element at the front of the buffer; if it is full, an element at the back is dropped to ma...">push_front()</a> on a <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> with zero capacity results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a4fc0d4e8c9e022a75daaef114fff12c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc0d4e8c9e022a75daaef114fff12c0">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7036c8bfac0cbe4d12f21febc7e069c0">reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first element of the reversed container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classgul17_1_1SlidingBuffer.html#ab2993ba19df341d7edf780293a64b828" title="Return an iterator to the element following the last element of the container.">end()</a>. </p>

</div>
</div>
<a id="a48733b4ec8753acddb4155596c6b5acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48733b4ec8753acddb4155596c6b5acc">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a7036c8bfac0cbe4d12f21febc7e069c0">reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the element following the last element of the reversed container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="ab7d5f6ad9719bdf7adf6fe095cb30e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d5f6ad9719bdf7adf6fe095cb30e2b">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SlidingBuffer__h.html#gaff3db063c4badc364a003d2b53f59897">ShrinkBehavior</a>&#160;</td>
          <td class="paramname"><em>shrink_behavior</em> = <code>ShrinkBehavior::keep_front_elements</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the container (identical to <a class="el" href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89" title="Resize the container.">resize()</a>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89" title="Resize the container.">resize()</a> </dd></dl>

</div>
</div>
<a id="a5e64c3e8e501717e2caca419b235fa89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e64c3e8e501717e2caca419b235fa89">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>&#160;</td>
          <td class="paramname"><em>new_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SlidingBuffer__h.html#gaff3db063c4badc364a003d2b53f59897">ShrinkBehavior</a>&#160;</td>
          <td class="paramname"><em>shrink_behavior</em> = <code>ShrinkBehavior::keep_front_elements</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the container. </p>
<p>Only possible if the underlying container is a std::vector.</p>
<ul>
<li>Shrinking: The excess elements are dropped according to <b><code>shrink_behavior</code></b>.</li>
<li>Growing: The capacity changes, but the (used) size does not. It will grow gradually when elements are pushed, as in the startup phase.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_capacity</td><td>New capacity (maximum size) of the sliding buffer. </td></tr>
    <tr><td class="paramname">shrink_behavior</td><td>Specify the <a class="el" href="group__SlidingBuffer__h.html#gaff3db063c4badc364a003d2b53f59897">ShrinkBehavior</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Think twice when shrinking the buffer: The default <code>shrink_behavior</code> (ShrinkBehavior::keep_front_elements) is transparent only if exclusively <a class="el" href="classgul17_1_1SlidingBuffer.html#a6b76a482abef03edeb5e419b3f0b9a37" title="Insert one element at the front of the buffer; if it is full, an element at the back is dropped to ma...">push_front()</a> was used to add elements. If <a class="el" href="classgul17_1_1SlidingBuffer.html#a2dd0eeb815fc15462a54dfe0f5638c2d" title="Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...">push_back()</a> was used, <a class="el" href="classgul17_1_1SlidingBuffer.html#a5e64c3e8e501717e2caca419b235fa89" title="Resize the container.">resize()</a> without a second argument discards the most recent elements; in these cases, make sure to specify ShrinkBehavior::keep_back_elements. </dd></dl>

</div>
</div>
<a id="a81654a64671df1d14fbb90402e961d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81654a64671df1d14fbb90402e961d38">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul17_1_1SlidingBuffer.html">gul17::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul17_1_1SlidingBuffer.html#a8c52abaadd4d2cca55f508904a2892b8">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements in the container, i.e. </p>
<p>std::distance(<a class="el" href="classgul17_1_1SlidingBuffer.html#a5feacc75b8e2672bfce722f9c7d5ec3d" title="Return an iterator to the first element of the container.">begin()</a>, <a class="el" href="classgul17_1_1SlidingBuffer.html#ab2993ba19df341d7edf780293a64b828" title="Return an iterator to the element following the last element of the container.">end()</a>).</p>
<p>In the startup phase it can be 0 and up to the <b><code>fixed_capacity</code></b> or <a class="el" href="classgul17_1_1SlidingBuffer.html#a6e70351dc3956330ee3da795d84852f0" title="Return the maximum possible number of elements in the container.">capacity()</a>, after startup (<a class="el" href="classgul17_1_1SlidingBuffer.html#acad96b773ad51142cb20726fc421e861" title="Return true if the buffer is completely filled with elements.">filled()</a> == true) it will always return <b><code>fixed_capacity</code></b> resp. <a class="el" href="classgul17_1_1SlidingBuffer.html#a6e70351dc3956330ee3da795d84852f0" title="Return the maximum possible number of elements in the container.">capacity()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SlidingBuffer_8h_source.html">SlidingBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer"><small>
  General Utility Library for C++17 &middot;
  <a href="https://www.desy.de/imprint/index_eng.html">Legal Disclosure</a> &middot;
  <a href="https://www.desy.de/data_privacy_policy/index_eng.html">Privacy Policy</a>
  <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
</small></address>
</body>
</html>
