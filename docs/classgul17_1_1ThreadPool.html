<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>General Utility Library for C++17: gul17::ThreadPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="gul17.png"/></td>
  <td id="projectalign">
   <div id="projectname">General Utility Library for C++17<span id="projectnumber">&#160;25.7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegul17.html">gul17</a></li><li class="navelem"><a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classgul17_1_1ThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">gul17::ThreadPool Class Reference<div class="ingroups"><a class="el" href="group__ThreadPool__h.html">gul17/ThreadPool.h</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A pool of worker threads with a task queue. </p>
<p>A thread pool is created with <a class="el" href="group__ThreadPool__h.html#ga21a74a855b5c2df1daa3584eadd276fc" title="Create a thread pool with the desired number of threads and the specified capacity for queuing tasks.">make_thread_pool()</a>. It immediately starts the desired number of worker threads and keeps them running until the object gets destroyed. Work is given to the pool with the <a class="el" href="classgul17_1_1ThreadPool.html#a2f899d33b93dc4cc8b9c5ba628d9fe7b" title="Enqueue a task.">add_task()</a> function in the form of a function object or function pointer. Tasks are stored in a queue and executed in the order they were added. This makes a <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> with a single thread effectively a serial task queue.</p>
<p>Each task is associated with a <a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html" title="A handle for a task that has (or had) been enqueued on a ThreadPool.">TaskHandle</a>. This handle is returned by <a class="el" href="classgul17_1_1ThreadPool.html#a2f899d33b93dc4cc8b9c5ba628d9fe7b" title="Enqueue a task.">add_task()</a> and can be used to query the status of the task or to remove it from the queue via <a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html#a956a2c3648f908d73236e107f2e0f76e">cancel()</a>. Tasks that are already running cannot be canceled.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">pool</a> = <a class="code hl_function" href="group__ThreadPool__h.html#ga21a74a855b5c2df1daa3584eadd276fc">make_thread_pool</a>(1);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">task</a> = <a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">pool</a>-&gt;add_task([]() { <span class="keywordflow">return</span> 42; });</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">not</a> <a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">task</a>.is_complete())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for task to complete...\n&quot;</span>;</div>
<div class="line">    <a class="code hl_function" href="group__time__util__h.html#gaba1f5593c8dd9d3b9e56f20ca103ec29">sleep</a>(0.1);</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Task result: &quot;</span> &lt;&lt; <a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">task</a>.get_result() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="agroup__ThreadPool__h_html_ga21a74a855b5c2df1daa3584eadd276fc"><div class="ttname"><a href="group__ThreadPool__h.html#ga21a74a855b5c2df1daa3584eadd276fc">gul17::make_thread_pool</a></div><div class="ttdeci">std::shared_ptr&lt; ThreadPool &gt; make_thread_pool(std::size_t num_threads, std::size_t capacity=ThreadPool::default_capacity)</div><div class="ttdoc">Create a thread pool with the desired number of threads and the specified capacity for queuing tasks.</div><div class="ttdef"><b>Definition</b> ThreadPool.h:625</div></div>
<div class="ttc" id="agroup__bit__manip__h_html_ga360badd8e0d73d0b45a028a10ec2d412"><div class="ttname"><a href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">gul17::bit_set</a></div><div class="ttdeci">auto constexpr bit_set(unsigned bit) noexcept -&gt; ReturnT</div><div class="ttdoc">Set a bit in an integral type.</div><div class="ttdef"><b>Definition</b> bit_manip.h:121</div></div>
<div class="ttc" id="agroup__time__util__h_html_gaba1f5593c8dd9d3b9e56f20ca103ec29"><div class="ttname"><a href="group__time__util__h.html#gaba1f5593c8dd9d3b9e56f20ca103ec29">gul17::sleep</a></div><div class="ttdeci">bool sleep(const std::chrono::duration&lt; Rep, Period &gt; &amp;duration, const Trigger &amp;trg)</div><div class="ttdoc">Sleep for at least the given time span, with the option of being woken up from another thread.</div><div class="ttdef"><b>Definition</b> time_util.h:114</div></div>
</div><!-- fragment --><p>Tasks can also be scheduled to start after a specific time point or after a certain delay. Each task can also be given a name, which is mainly useful for debugging. See the <a class="el" href="thread_pool_8cc-example.html">example</a> for an introduction.</p>
<p>All public member functions are thread-safe.</p>
<p>On Linux, threads in the pool explicitly block the signals SIGALRM, SIGINT, SIGPIPE, SIGTERM, SIGURG, SIGUSR1, and SIGUSR2. This is done to prevent the threads from terminating the whole process if one of these signals is received.</p>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.11 </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="thread_pool_8cc-example.html#_a0">thread_pool.cc</a>.</dd>
</dl>
</div>
<p><code>#include &lt;<a class="el" href="ThreadPool_8h_source.html">ThreadPool.h</a>&gt;</code></p>

<p>Inherits std::enable_shared_from_this&lt; ThreadPool &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for a task that has (or had) been enqueued on a <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a>.  <a href="classgul17_1_1ThreadPool_1_1TaskHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad0f1903ea6ad20b7e61c1a9dada2826f" id="r_ad0f1903ea6ad20b7e61c1a9dada2826f"><td class="memItemLeft" align="right" valign="top"><a id="ad0f1903ea6ad20b7e61c1a9dada2826f" name="ad0f1903ea6ad20b7e61c1a9dada2826f"></a>
<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TaskId</b> = std::uint64_t</td></tr>
<tr class="memdesc:ad0f1903ea6ad20b7e61c1a9dada2826f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique identifier for a task. <br /></td></tr>
<tr class="separator:ad0f1903ea6ad20b7e61c1a9dada2826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147cbf47f90a81c678c0cb65911225b9" id="r_a147cbf47f90a81c678c0cb65911225b9"><td class="memItemLeft" align="right" valign="top"><a id="a147cbf47f90a81c678c0cb65911225b9" name="a147cbf47f90a81c678c0cb65911225b9"></a>
<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadId</b> = std::vector&lt; std::thread &gt;::size_type</td></tr>
<tr class="memdesc:a147cbf47f90a81c678c0cb65911225b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique identifier for a thread in the pool in the range of [0, <a class="el" href="classgul17_1_1ThreadPool.html#a2acfe35568ba5fc8bf7389cc60d7dff3" title="Return the number of threads in the pool.">count_threads()</a>). <br /></td></tr>
<tr class="separator:a147cbf47f90a81c678c0cb65911225b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4277976cb671e175fbd3d6aef47f5af" id="r_ac4277976cb671e175fbd3d6aef47f5af"><td class="memItemLeft" align="right" valign="top"><a id="ac4277976cb671e175fbd3d6aef47f5af" name="ac4277976cb671e175fbd3d6aef47f5af"></a>
<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TimePoint</b> = std::chrono::time_point&lt; std::chrono::system_clock &gt;</td></tr>
<tr class="separator:ac4277976cb671e175fbd3d6aef47f5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08718bfa9001c744b25084cf2fc6316f" id="r_a08718bfa9001c744b25084cf2fc6316f"><td class="memItemLeft" align="right" valign="top"><a id="a08718bfa9001c744b25084cf2fc6316f" name="a08718bfa9001c744b25084cf2fc6316f"></a>
<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Duration</b> = TimePoint::duration</td></tr>
<tr class="separator:a08718bfa9001c744b25084cf2fc6316f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0fad3bafdc1110161c98117f68f76a5f" id="r_a0fad3bafdc1110161c98117f68f76a5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a0fad3bafdc1110161c98117f68f76a5f">~ThreadPool</a> ()</td></tr>
<tr class="memdesc:a0fad3bafdc1110161c98117f68f76a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> and join all threads.  <br /></td></tr>
<tr class="separator:a0fad3bafdc1110161c98117f68f76a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f899d33b93dc4cc8b9c5ba628d9fe7b" id="r_a2f899d33b93dc4cc8b9c5ba628d9fe7b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">typename</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> &gt; </td></tr>
<tr class="memitem:a2f899d33b93dc4cc8b9c5ba628d9fe7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; std::invoke_result_t&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a>, <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a2f899d33b93dc4cc8b9c5ba628d9fe7b">add_task</a> (<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">fct</a>, TimePoint <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">start_time</a>={}, std::string <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">name</a>={})</td></tr>
<tr class="memdesc:a2f899d33b93dc4cc8b9c5ba628d9fe7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a task.  <br /></td></tr>
<tr class="separator:a2f899d33b93dc4cc8b9c5ba628d9fe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bea3c6528e2e13b9a812ca92494b9d" id="r_aa1bea3c6528e2e13b9a812ca92494b9d"><td class="memTemplParams" colspan="2"><a id="aa1bea3c6528e2e13b9a812ca92494b9d" name="aa1bea3c6528e2e13b9a812ca92494b9d"></a>
template&lt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">typename</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> , std::enable_if_t&lt; std::is_invocable&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> &gt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">::value</a>, <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">bool</a> &gt;  = true&gt; </td></tr>
<tr class="memitem:aa1bea3c6528e2e13b9a812ca92494b9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; std::invoke_result_t&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_task</b> (<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">fct</a>, TimePoint <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">start_time</a>={}, std::string <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">name</a>={})</td></tr>
<tr class="separator:aa1bea3c6528e2e13b9a812ca92494b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ba21b97fb194712291c40d4eab2529" id="r_ae7ba21b97fb194712291c40d4eab2529"><td class="memTemplParams" colspan="2"><a id="ae7ba21b97fb194712291c40d4eab2529" name="ae7ba21b97fb194712291c40d4eab2529"></a>
template&lt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">typename</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> , std::enable_if_t&lt; std::is_invocable&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a>, <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &amp; &gt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">::value</a>, <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">bool</a> &gt;  = true&gt; </td></tr>
<tr class="memitem:ae7ba21b97fb194712291c40d4eab2529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; std::invoke_result_t&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a>, <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_task</b> (<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">fct</a>, Duration <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">delay_before_start</a>, std::string <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">name</a>={})</td></tr>
<tr class="separator:ae7ba21b97fb194712291c40d4eab2529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86d251ae625ffc99327dc8dcd25b31f" id="r_ab86d251ae625ffc99327dc8dcd25b31f"><td class="memTemplParams" colspan="2"><a id="ab86d251ae625ffc99327dc8dcd25b31f" name="ab86d251ae625ffc99327dc8dcd25b31f"></a>
template&lt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">typename</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> , std::enable_if_t&lt; std::is_invocable&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> &gt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">::value</a>, <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">bool</a> &gt;  = true&gt; </td></tr>
<tr class="memitem:ab86d251ae625ffc99327dc8dcd25b31f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; std::invoke_result_t&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_task</b> (<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">fct</a>, Duration <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">delay_before_start</a>, std::string <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">name</a>={})</td></tr>
<tr class="separator:ab86d251ae625ffc99327dc8dcd25b31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39a446dee20d8c32e68aa7a9ee36a21" id="r_ae39a446dee20d8c32e68aa7a9ee36a21"><td class="memTemplParams" colspan="2"><a id="ae39a446dee20d8c32e68aa7a9ee36a21" name="ae39a446dee20d8c32e68aa7a9ee36a21"></a>
template&lt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">typename</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> , std::enable_if_t&lt; std::is_invocable&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a>, <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &amp; &gt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">::value</a>, <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">bool</a> &gt;  = true&gt; </td></tr>
<tr class="memitem:ae39a446dee20d8c32e68aa7a9ee36a21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; std::invoke_result_t&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a>, <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_task</b> (<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">fct</a>, std::string <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">name</a>)</td></tr>
<tr class="separator:ae39a446dee20d8c32e68aa7a9ee36a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d1114a9b3b2d79915a2eff20227eb3" id="r_a83d1114a9b3b2d79915a2eff20227eb3"><td class="memTemplParams" colspan="2"><a id="a83d1114a9b3b2d79915a2eff20227eb3" name="a83d1114a9b3b2d79915a2eff20227eb3"></a>
template&lt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">typename</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> , std::enable_if_t&lt; std::is_invocable&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> &gt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">::value</a>, <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">bool</a> &gt;  = true&gt; </td></tr>
<tr class="memitem:a83d1114a9b3b2d79915a2eff20227eb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; std::invoke_result_t&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_task</b> (<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">fct</a>, std::string <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">name</a>)</td></tr>
<tr class="separator:a83d1114a9b3b2d79915a2eff20227eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383fc50afd172fc9dfaf9909796ae4a" id="r_ad383fc50afd172fc9dfaf9909796ae4a"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#ad383fc50afd172fc9dfaf9909796ae4a">cancel_pending_tasks</a> ()</td></tr>
<tr class="memdesc:ad383fc50afd172fc9dfaf9909796ae4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all pending tasks from the queue.  <br /></td></tr>
<tr class="separator:ad383fc50afd172fc9dfaf9909796ae4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13aacb993857889444e13cbd29d293c" id="r_af13aacb993857889444e13cbd29d293c"><td class="memItemLeft" align="right" valign="top"><a id="af13aacb993857889444e13cbd29d293c" name="af13aacb993857889444e13cbd29d293c"></a>
GUL_EXPORT std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">const</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">noexcept</a></td></tr>
<tr class="memdesc:af13aacb993857889444e13cbd29d293c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of pending tasks that can be queued. <br /></td></tr>
<tr class="separator:af13aacb993857889444e13cbd29d293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3302db587ad34ca2e331af2e8edc9bb" id="r_ad3302db587ad34ca2e331af2e8edc9bb"><td class="memItemLeft" align="right" valign="top"><a id="ad3302db587ad34ca2e331af2e8edc9bb" name="ad3302db587ad34ca2e331af2e8edc9bb"></a>
GUL_EXPORT std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>count_pending</b> () <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">const</a></td></tr>
<tr class="memdesc:ad3302db587ad34ca2e331af2e8edc9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of pending tasks. <br /></td></tr>
<tr class="separator:ad3302db587ad34ca2e331af2e8edc9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acfe35568ba5fc8bf7389cc60d7dff3" id="r_a2acfe35568ba5fc8bf7389cc60d7dff3"><td class="memItemLeft" align="right" valign="top"><a id="a2acfe35568ba5fc8bf7389cc60d7dff3" name="a2acfe35568ba5fc8bf7389cc60d7dff3"></a>
GUL_EXPORT std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>count_threads</b> () <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">const</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">noexcept</a></td></tr>
<tr class="memdesc:a2acfe35568ba5fc8bf7389cc60d7dff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of threads in the pool. <br /></td></tr>
<tr class="separator:a2acfe35568ba5fc8bf7389cc60d7dff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904c1a65f895e24d774bd31d400210b5" id="r_a904c1a65f895e24d774bd31d400210b5"><td class="memItemLeft" align="right" valign="top"><a id="a904c1a65f895e24d774bd31d400210b5" name="a904c1a65f895e24d774bd31d400210b5"></a>
GUL_EXPORT std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_pending_task_names</b> () <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">const</a></td></tr>
<tr class="memdesc:a904c1a65f895e24d774bd31d400210b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with the names of the tasks that are waiting to be executed. <br /></td></tr>
<tr class="separator:a904c1a65f895e24d774bd31d400210b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f82e50aa29541ae1bd296c8df868e4" id="r_a48f82e50aa29541ae1bd296c8df868e4"><td class="memItemLeft" align="right" valign="top"><a id="a48f82e50aa29541ae1bd296c8df868e4" name="a48f82e50aa29541ae1bd296c8df868e4"></a>
GUL_EXPORT std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_running_task_names</b> () <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">const</a></td></tr>
<tr class="memdesc:a48f82e50aa29541ae1bd296c8df868e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with the names of the tasks that are currently running. <br /></td></tr>
<tr class="separator:a48f82e50aa29541ae1bd296c8df868e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa251e54af1cfdcf047abc9a0ac69f19c" id="r_aa251e54af1cfdcf047abc9a0ac69f19c"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT <a class="el" href="classgul17_1_1ThreadPool.html#a147cbf47f90a81c678c0cb65911225b9">ThreadId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#aa251e54af1cfdcf047abc9a0ac69f19c">get_thread_id</a> () <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">const</a></td></tr>
<tr class="memdesc:aa251e54af1cfdcf047abc9a0ac69f19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread pool ID of the current thread.  <br /></td></tr>
<tr class="separator:aa251e54af1cfdcf047abc9a0ac69f19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b05d19dbb474f79eabef0d0ab9abcf" id="r_a68b05d19dbb474f79eabef0d0ab9abcf"><td class="memItemLeft" align="right" valign="top"><a id="a68b05d19dbb474f79eabef0d0ab9abcf" name="a68b05d19dbb474f79eabef0d0ab9abcf"></a>
GUL_EXPORT <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_full</b> () <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">const</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">noexcept</a></td></tr>
<tr class="memdesc:a68b05d19dbb474f79eabef0d0ab9abcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the queue for pending tasks is full (at capacity). <br /></td></tr>
<tr class="separator:a68b05d19dbb474f79eabef0d0ab9abcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617de4746563e7b496376f5e55fd5963" id="r_a617de4746563e7b496376f5e55fd5963"><td class="memItemLeft" align="right" valign="top"><a id="a617de4746563e7b496376f5e55fd5963" name="a617de4746563e7b496376f5e55fd5963"></a>
GUL_EXPORT <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_idle</b> () <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">const</a></td></tr>
<tr class="memdesc:a617de4746563e7b496376f5e55fd5963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the pool has neither pending tasks nor tasks that are currently being executed. <br /></td></tr>
<tr class="separator:a617de4746563e7b496376f5e55fd5963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8d754eface352e9850a70c122f4ba4" id="r_a3a8d754eface352e9850a70c122f4ba4"><td class="memItemLeft" align="right" valign="top"><a id="a3a8d754eface352e9850a70c122f4ba4" name="a3a8d754eface352e9850a70c122f4ba4"></a>
GUL_EXPORT <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_shutdown_requested</b> () <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">const</a></td></tr>
<tr class="memdesc:a3a8d754eface352e9850a70c122f4ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the thread pool has been requested to shut down. <br /></td></tr>
<tr class="separator:a3a8d754eface352e9850a70c122f4ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a79212ccd26c724dc40446e9f0d6386db" id="r_a79212ccd26c724dc40446e9f0d6386db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">static</a> GUL_EXPORT std::shared_ptr&lt; <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a79212ccd26c724dc40446e9f0d6386db">make_shared</a> (std::size_t <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">num_threads</a>, std::size_t <a class="el" href="classgul17_1_1ThreadPool.html#af13aacb993857889444e13cbd29d293c">capacity</a>=<a class="el" href="classgul17_1_1ThreadPool.html#a177512121c48c7ffc0e099d27ba6c650">default_capacity</a>)</td></tr>
<tr class="memdesc:a79212ccd26c724dc40446e9f0d6386db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread pool with the desired number of threads and the specified capacity for enqueuing tasks.  <br /></td></tr>
<tr class="separator:a79212ccd26c724dc40446e9f0d6386db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a177512121c48c7ffc0e099d27ba6c650" id="r_a177512121c48c7ffc0e099d27ba6c650"><td class="memItemLeft" align="right" valign="top"><a id="a177512121c48c7ffc0e099d27ba6c650" name="a177512121c48c7ffc0e099d27ba6c650"></a>
<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">static</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">constexpr</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>default_capacity</b> { 200 }</td></tr>
<tr class="memdesc:a177512121c48c7ffc0e099d27ba6c650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default capacity for the task queue. <br /></td></tr>
<tr class="separator:a177512121c48c7ffc0e099d27ba6c650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564063e4774cdbe872b97b16e14c6aa5" id="r_a564063e4774cdbe872b97b16e14c6aa5"><td class="memItemLeft" align="right" valign="top"><a id="a564063e4774cdbe872b97b16e14c6aa5" name="a564063e4774cdbe872b97b16e14c6aa5"></a>
<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">static</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">constexpr</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_capacity</b> { 10'000'000 }</td></tr>
<tr class="memdesc:a564063e4774cdbe872b97b16e14c6aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum possible capacity for the task queue. <br /></td></tr>
<tr class="separator:a564063e4774cdbe872b97b16e14c6aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af211669f155adb305811fc259a21e2d1" id="r_af211669f155adb305811fc259a21e2d1"><td class="memItemLeft" align="right" valign="top"><a id="af211669f155adb305811fc259a21e2d1" name="af211669f155adb305811fc259a21e2d1"></a>
<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">static</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">constexpr</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_threads</b> { 10'000 }</td></tr>
<tr class="memdesc:af211669f155adb305811fc259a21e2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum possible number of threads. <br /></td></tr>
<tr class="separator:af211669f155adb305811fc259a21e2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0fad3bafdc1110161c98117f68f76a5f" name="a0fad3bafdc1110161c98117f68f76a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fad3bafdc1110161c98117f68f76a5f">&#9670;&#160;</a></span>~ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gul17::ThreadPool::~ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct the <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> and join all threads. </p>
<p>This destructor blocks until all threads have terminated. Work that has not yet been started in one of the threads gets canceled, but work that has already been assigned to a thread continues to be executed until it completes. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2f899d33b93dc4cc8b9c5ba628d9fe7b" name="a2f899d33b93dc4cc8b9c5ba628d9fe7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f899d33b93dc4cc8b9c5ba628d9fe7b">&#9670;&#160;</a></span>add_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">typename</a> <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; std::invoke_result_t&lt; <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a>, <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &amp; &gt; &gt; gul17::ThreadPool::add_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">Function</a>&#160;</td>
          <td class="paramname"><em>fct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimePoint&#160;</td>
          <td class="paramname"><em>start_time</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a task. </p>
<p>There are multiple overloads of this function for variations of the arguments:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fct</td><td>A function object or function pointer to be executed. This function can have an arbitrary return type and may either take no arguments (<code>T <a class="el" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412" title="Set a bit in an integral type.">fct()</a></code>) or a reference to the <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> by which it gets executed (<code>T fct(<a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a>&amp;)</code>). </td></tr>
    <tr><td class="paramname">start_time</td><td>Earliest time point at which the task is to be started </td></tr>
    <tr><td class="paramname">name</td><td>Optional name for the task (mainly for debugging)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html" title="A handle for a task that has (or had) been enqueued on a ThreadPool.">TaskHandle</a> that can be used for inquiries about the state of the task and to retrieve its return value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>is thrown if the queue is full.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">pool</a> = <a class="code hl_function" href="group__ThreadPool__h.html#ga21a74a855b5c2df1daa3584eadd276fc">make_thread_pool</a>(2); <span class="comment">// Create a pool with 2 threads</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A simple task that does not interact with the pool</span></div>
<div class="line"><a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">pool</a>-&gt;add_task([]() { std::cout &lt;&lt; <span class="stringliteral">&quot;Task 1\n&quot;</span>; });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A task that schedules another task to start two seconds later</span></div>
<div class="line"><a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">pool</a>-&gt;add_task(</div>
<div class="line">    [](<a class="code hl_class" href="classgul17_1_1ThreadPool.html">ThreadPool</a>&amp; <a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">pool</a>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Task 2\n&quot;</span>;</div>
<div class="line">        <a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">pool</a>.add_task([]() { std::cout &lt;&lt; <span class="stringliteral">&quot;Task 3\n&quot;</span>; }, 2<a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">s</a>);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A task with a name</span></div>
<div class="line"><a class="code hl_function" href="group__bit__manip__h.html#ga360badd8e0d73d0b45a028a10ec2d412">pool</a>-&gt;add_task([]() { std::cout &lt;&lt; <span class="stringliteral">&quot;Task 4\n&quot;</span>; }, <span class="stringliteral">&quot;Task 4&quot;</span>);</div>
<div class="ttc" id="aclassgul17_1_1ThreadPool_html"><div class="ttname"><a href="classgul17_1_1ThreadPool.html">gul17::ThreadPool</a></div><div class="ttdoc">A pool of worker threads with a task queue.</div><div class="ttdef"><b>Definition</b> ThreadPool.h:111</div></div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>GUL version 2.12.1, <a class="el" href="classgul17_1_1ThreadPool.html#a2f899d33b93dc4cc8b9c5ba628d9fe7b" title="Enqueue a task.">add_task()</a> unconditionally accepts mutable function objects </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="thread_pool_8cc-example.html#a1">thread_pool.cc</a>.</dd>
</dl>

</div>
</div>
<a id="ad383fc50afd172fc9dfaf9909796ae4a" name="ad383fc50afd172fc9dfaf9909796ae4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad383fc50afd172fc9dfaf9909796ae4a">&#9670;&#160;</a></span>cancel_pending_tasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t gul17::ThreadPool::cancel_pending_tasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all pending tasks from the queue. </p>
<p>This call removes all tasks that have not yet been started from the queue. It has no impact on tasks that are currently being executed.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of tasks that were removed. </dd></dl>

</div>
</div>
<a id="aa251e54af1cfdcf047abc9a0ac69f19c" name="aa251e54af1cfdcf047abc9a0ac69f19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa251e54af1cfdcf047abc9a0ac69f19c">&#9670;&#160;</a></span>get_thread_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul17_1_1ThreadPool.html#a147cbf47f90a81c678c0cb65911225b9">ThreadPool::ThreadId</a> gul17::ThreadPool::get_thread_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the thread pool ID of the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>a thread ID in the range [0, <a class="el" href="classgul17_1_1ThreadPool.html#a2acfe35568ba5fc8bf7389cc60d7dff3" title="Return the number of threads in the pool.">count_threads()</a>).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>is thrown if this function is called from a thread that is not part of the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.13 </dd></dl>

</div>
</div>
<a id="a79212ccd26c724dc40446e9f0d6386db" name="a79212ccd26c724dc40446e9f0d6386db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79212ccd26c724dc40446e9f0d6386db">&#9670;&#160;</a></span>make_shared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &gt; gul17::ThreadPool::make_shared </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em> = <code><a class="el" href="classgul17_1_1ThreadPool.html#a177512121c48c7ffc0e099d27ba6c650">default_capacity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a thread pool with the desired number of threads and the specified capacity for enqueuing tasks. </p>
<p>The thread pool is allocated in a shared pointer, which is necessary so that task handles can access the pool safely. A <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> cannot be constructed directly.</p>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to the created <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> object. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__ThreadPool__h.html#ga21a74a855b5c2df1daa3584eadd276fc">gul17::make_thread_pool()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ThreadPool_8h_source.html">ThreadPool.h</a></li>
<li><a class="el" href="ThreadPool_8cc.html">ThreadPool.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer"><small>
  General Utility Library for C++17 &middot;
  <a href="https://www.desy.de/imprint/index_eng.html">Legal Disclosure</a> &middot;
  <a href="https://www.desy.de/data_privacy_policy/index_eng.html">Privacy Policy</a>
  <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
</small></address>
</body>
</html>
