<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>General Utility Library for C++17: gul17::ThreadPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gul17.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">General Utility Library for C++17
   &#160;<span id="projectnumber">2.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegul17.html">gul17</a></li><li class="navelem"><a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classgul17_1_1ThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gul17::ThreadPool Class Reference<div class="ingroups"><a class="el" href="group__ThreadPool__h.html">gul17/ThreadPool.h</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A pool of worker threads with a task queue. </p>
<p>A thread pool is created with <a class="el" href="group__ThreadPool__h.html#gaeb910daff6ce7c95de6d4d468f04fc29" title="Create a thread pool with the desired number of threads and the specified capacity for queuing tasks.">make_thread_pool()</a>. It immediately starts the desired number of worker threads and keeps them running until the object gets destroyed. Work is given to the pool with the <a class="el" href="classgul17_1_1ThreadPool.html#a9ab799d844fe310740c39d7465ec192d" title="Enqueue a task.">add_task()</a> function in the form of a function object or function pointer. Tasks are stored in a queue and executed in the order they were added. This makes a <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> with a single thread effectively a serial task queue.</p>
<p>Each task is associated with a <a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html" title="A handle for a task that has (or had) been enqueued on a ThreadPool.">TaskHandle</a>. This handle is returned by <a class="el" href="classgul17_1_1ThreadPool.html#a9ab799d844fe310740c39d7465ec192d" title="Enqueue a task.">add_task()</a> and can be used to query the status of the task or to remove it from the queue via <a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html#a956a2c3648f908d73236e107f2e0f76e">cancel()</a>. Tasks that are already running cannot be canceled.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pool = <a class="code" href="group__ThreadPool__h.html#gaeb910daff6ce7c95de6d4d468f04fc29">make_thread_pool</a>(1);</div>
<div class="line"><span class="keyword">auto</span> task = pool-&gt;add_task([]() { <span class="keywordflow">return</span> 42; });</div>
<div class="line"><span class="keywordflow">while</span> (not task.is_complete())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for task to complete...\n&quot;</span>;</div>
<div class="line">    <a class="code" href="group__time__util__h.html#gaba1f5593c8dd9d3b9e56f20ca103ec29">sleep</a>(0.1);</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Task result: &quot;</span> &lt;&lt; task.get_result() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="agroup__ThreadPool__h_html_gaeb910daff6ce7c95de6d4d468f04fc29"><div class="ttname"><a href="group__ThreadPool__h.html#gaeb910daff6ce7c95de6d4d468f04fc29">gul17::make_thread_pool</a></div><div class="ttdeci">std::shared_ptr&lt; ThreadPool &gt; make_thread_pool(std::size_t num_threads, std::size_t capacity=ThreadPool::default_capacity)</div><div class="ttdoc">Create a thread pool with the desired number of threads and the specified capacity for queuing tasks.</div><div class="ttdef"><b>Definition:</b> ThreadPool.h:599</div></div>
<div class="ttc" id="agroup__time__util__h_html_gaba1f5593c8dd9d3b9e56f20ca103ec29"><div class="ttname"><a href="group__time__util__h.html#gaba1f5593c8dd9d3b9e56f20ca103ec29">gul17::sleep</a></div><div class="ttdeci">bool sleep(const std::chrono::duration&lt; Rep, Period &gt; &amp;duration, const Trigger &amp;trg)</div><div class="ttdoc">Sleep for at least the given time span, with the option of being woken up from another thread.</div><div class="ttdef"><b>Definition:</b> time_util.h:114</div></div>
</div><!-- fragment --><p>Tasks can also be scheduled to start after a specific time point or after a certain delay. Each task can also be given a name, which is mainly useful for debugging. See the <a class="el" href="thread_pool_8cc-example.html">example</a> for an introduction.</p>
<p>All public member functions are thread-safe.</p>
<p>On Linux, threads in the pool explicitly block the signals SIGALRM, SIGINT, SIGPIPE, SIGTERM, SIGURG, SIGUSR1, and SIGUSR2. This is done to prevent the threads from terminating the whole process if one of these signals is received.</p>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.11 </dd></dl>
</div>
<p><code>#include &lt;<a class="el" href="ThreadPool_8h_source.html">ThreadPool.h</a>&gt;</code></p>

<p>Inherits std::enable_shared_from_this&lt; ThreadPool &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for a task that has (or had) been enqueued on a <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a>.  <a href="classgul17_1_1ThreadPool_1_1TaskHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad0f1903ea6ad20b7e61c1a9dada2826f"><td class="memItemLeft" align="right" valign="top"><a id="ad0f1903ea6ad20b7e61c1a9dada2826f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#ad0f1903ea6ad20b7e61c1a9dada2826f">TaskId</a> = std::uint64_t</td></tr>
<tr class="memdesc:ad0f1903ea6ad20b7e61c1a9dada2826f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique identifier for a task. <br /></td></tr>
<tr class="separator:ad0f1903ea6ad20b7e61c1a9dada2826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4277976cb671e175fbd3d6aef47f5af"><td class="memItemLeft" align="right" valign="top"><a id="ac4277976cb671e175fbd3d6aef47f5af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TimePoint</b> = std::chrono::time_point&lt; std::chrono::system_clock &gt;</td></tr>
<tr class="separator:ac4277976cb671e175fbd3d6aef47f5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08718bfa9001c744b25084cf2fc6316f"><td class="memItemLeft" align="right" valign="top"><a id="a08718bfa9001c744b25084cf2fc6316f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Duration</b> = TimePoint::duration</td></tr>
<tr class="separator:a08718bfa9001c744b25084cf2fc6316f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0fad3bafdc1110161c98117f68f76a5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a0fad3bafdc1110161c98117f68f76a5f">~ThreadPool</a> ()</td></tr>
<tr class="memdesc:a0fad3bafdc1110161c98117f68f76a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> and join all threads.  <a href="classgul17_1_1ThreadPool.html#a0fad3bafdc1110161c98117f68f76a5f">More...</a><br /></td></tr>
<tr class="separator:a0fad3bafdc1110161c98117f68f76a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab799d844fe310740c39d7465ec192d"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a9ab799d844fe310740c39d7465ec192d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; <a class="el" href="group__traits__h.html#gafe64b28f921c9dabcc174187f6c52947">invoke_result_t</a>&lt; Function, <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a9ab799d844fe310740c39d7465ec192d">add_task</a> (Function fct, TimePoint start_time={}, std::string name={})</td></tr>
<tr class="memdesc:a9ab799d844fe310740c39d7465ec192d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a task.  <a href="classgul17_1_1ThreadPool.html#a9ab799d844fe310740c39d7465ec192d">More...</a><br /></td></tr>
<tr class="separator:a9ab799d844fe310740c39d7465ec192d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7939550d9cc809cc74306e6f743f287e"><td class="memTemplParams" colspan="2"><a id="a7939550d9cc809cc74306e6f743f287e"></a>
template&lt;typename Function , std::enable_if_t&lt; is_invocable&lt; Function &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a7939550d9cc809cc74306e6f743f287e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; <a class="el" href="group__traits__h.html#gafe64b28f921c9dabcc174187f6c52947">invoke_result_t</a>&lt; Function &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_task</b> (Function fct, TimePoint start_time={}, std::string name={})</td></tr>
<tr class="separator:a7939550d9cc809cc74306e6f743f287e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94af237ef31119b1850533a7ecee28ab"><td class="memTemplParams" colspan="2"><a id="a94af237ef31119b1850533a7ecee28ab"></a>
template&lt;typename Function , std::enable_if_t&lt; is_invocable&lt; Function, ThreadPool &amp; &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a94af237ef31119b1850533a7ecee28ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; <a class="el" href="group__traits__h.html#gafe64b28f921c9dabcc174187f6c52947">invoke_result_t</a>&lt; Function, <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_task</b> (Function fct, Duration delay_before_start, std::string name={})</td></tr>
<tr class="separator:a94af237ef31119b1850533a7ecee28ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa14558e558e975a7a99c536893ed7e"><td class="memTemplParams" colspan="2"><a id="aaaa14558e558e975a7a99c536893ed7e"></a>
template&lt;typename Function , std::enable_if_t&lt; is_invocable&lt; Function &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:aaaa14558e558e975a7a99c536893ed7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; <a class="el" href="group__traits__h.html#gafe64b28f921c9dabcc174187f6c52947">invoke_result_t</a>&lt; Function &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_task</b> (Function fct, Duration delay_before_start, std::string name={})</td></tr>
<tr class="separator:aaaa14558e558e975a7a99c536893ed7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2d2e616b9f554c5011596dd5001a46"><td class="memTemplParams" colspan="2"><a id="a6c2d2e616b9f554c5011596dd5001a46"></a>
template&lt;typename Function , std::enable_if_t&lt; is_invocable&lt; Function, ThreadPool &amp; &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a6c2d2e616b9f554c5011596dd5001a46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; <a class="el" href="group__traits__h.html#gafe64b28f921c9dabcc174187f6c52947">invoke_result_t</a>&lt; Function, <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_task</b> (Function fct, std::string name)</td></tr>
<tr class="separator:a6c2d2e616b9f554c5011596dd5001a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4beebebb72b29ebd75e61593264595"><td class="memTemplParams" colspan="2"><a id="a7d4beebebb72b29ebd75e61593264595"></a>
template&lt;typename Function , std::enable_if_t&lt; is_invocable&lt; Function &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a7d4beebebb72b29ebd75e61593264595"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt; <a class="el" href="group__traits__h.html#gafe64b28f921c9dabcc174187f6c52947">invoke_result_t</a>&lt; Function &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_task</b> (Function fct, std::string name)</td></tr>
<tr class="separator:a7d4beebebb72b29ebd75e61593264595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383fc50afd172fc9dfaf9909796ae4a"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#ad383fc50afd172fc9dfaf9909796ae4a">cancel_pending_tasks</a> ()</td></tr>
<tr class="memdesc:ad383fc50afd172fc9dfaf9909796ae4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all pending tasks from the queue.  <a href="classgul17_1_1ThreadPool.html#ad383fc50afd172fc9dfaf9909796ae4a">More...</a><br /></td></tr>
<tr class="separator:ad383fc50afd172fc9dfaf9909796ae4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13aacb993857889444e13cbd29d293c"><td class="memItemLeft" align="right" valign="top"><a id="af13aacb993857889444e13cbd29d293c"></a>
GUL_EXPORT std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#af13aacb993857889444e13cbd29d293c">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:af13aacb993857889444e13cbd29d293c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of pending tasks that can be queued. <br /></td></tr>
<tr class="separator:af13aacb993857889444e13cbd29d293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3302db587ad34ca2e331af2e8edc9bb"><td class="memItemLeft" align="right" valign="top"><a id="ad3302db587ad34ca2e331af2e8edc9bb"></a>
GUL_EXPORT std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#ad3302db587ad34ca2e331af2e8edc9bb">count_pending</a> () const</td></tr>
<tr class="memdesc:ad3302db587ad34ca2e331af2e8edc9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of pending tasks. <br /></td></tr>
<tr class="separator:ad3302db587ad34ca2e331af2e8edc9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acfe35568ba5fc8bf7389cc60d7dff3"><td class="memItemLeft" align="right" valign="top"><a id="a2acfe35568ba5fc8bf7389cc60d7dff3"></a>
GUL_EXPORT std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a2acfe35568ba5fc8bf7389cc60d7dff3">count_threads</a> () const noexcept</td></tr>
<tr class="memdesc:a2acfe35568ba5fc8bf7389cc60d7dff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of threads in the pool. <br /></td></tr>
<tr class="separator:a2acfe35568ba5fc8bf7389cc60d7dff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904c1a65f895e24d774bd31d400210b5"><td class="memItemLeft" align="right" valign="top"><a id="a904c1a65f895e24d774bd31d400210b5"></a>
GUL_EXPORT std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a904c1a65f895e24d774bd31d400210b5">get_pending_task_names</a> () const</td></tr>
<tr class="memdesc:a904c1a65f895e24d774bd31d400210b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with the names of the tasks that are waiting to be executed. <br /></td></tr>
<tr class="separator:a904c1a65f895e24d774bd31d400210b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f82e50aa29541ae1bd296c8df868e4"><td class="memItemLeft" align="right" valign="top"><a id="a48f82e50aa29541ae1bd296c8df868e4"></a>
GUL_EXPORT std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a48f82e50aa29541ae1bd296c8df868e4">get_running_task_names</a> () const</td></tr>
<tr class="memdesc:a48f82e50aa29541ae1bd296c8df868e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with the names of the tasks that are currently running. <br /></td></tr>
<tr class="separator:a48f82e50aa29541ae1bd296c8df868e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b05d19dbb474f79eabef0d0ab9abcf"><td class="memItemLeft" align="right" valign="top"><a id="a68b05d19dbb474f79eabef0d0ab9abcf"></a>
GUL_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a68b05d19dbb474f79eabef0d0ab9abcf">is_full</a> () const noexcept</td></tr>
<tr class="memdesc:a68b05d19dbb474f79eabef0d0ab9abcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the queue for pending tasks is full (at capacity). <br /></td></tr>
<tr class="separator:a68b05d19dbb474f79eabef0d0ab9abcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617de4746563e7b496376f5e55fd5963"><td class="memItemLeft" align="right" valign="top"><a id="a617de4746563e7b496376f5e55fd5963"></a>
GUL_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a617de4746563e7b496376f5e55fd5963">is_idle</a> () const</td></tr>
<tr class="memdesc:a617de4746563e7b496376f5e55fd5963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the pool has neither pending tasks nor tasks that are currently being executed. <br /></td></tr>
<tr class="separator:a617de4746563e7b496376f5e55fd5963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8d754eface352e9850a70c122f4ba4"><td class="memItemLeft" align="right" valign="top"><a id="a3a8d754eface352e9850a70c122f4ba4"></a>
GUL_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a3a8d754eface352e9850a70c122f4ba4">is_shutdown_requested</a> () const</td></tr>
<tr class="memdesc:a3a8d754eface352e9850a70c122f4ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the thread pool has been requested to shut down. <br /></td></tr>
<tr class="separator:a3a8d754eface352e9850a70c122f4ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a79212ccd26c724dc40446e9f0d6386db"><td class="memItemLeft" align="right" valign="top">static GUL_EXPORT std::shared_ptr&lt; <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a79212ccd26c724dc40446e9f0d6386db">make_shared</a> (std::size_t num_threads, std::size_t <a class="el" href="classgul17_1_1ThreadPool.html#af13aacb993857889444e13cbd29d293c">capacity</a>=<a class="el" href="classgul17_1_1ThreadPool.html#abb6528ba65ba4fbb472ea7a8787ae390">default_capacity</a>)</td></tr>
<tr class="memdesc:a79212ccd26c724dc40446e9f0d6386db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread pool with the desired number of threads and the specified capacity for enqueuing tasks.  <a href="classgul17_1_1ThreadPool.html#a79212ccd26c724dc40446e9f0d6386db">More...</a><br /></td></tr>
<tr class="separator:a79212ccd26c724dc40446e9f0d6386db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:abb6528ba65ba4fbb472ea7a8787ae390"><td class="memItemLeft" align="right" valign="top"><a id="abb6528ba65ba4fbb472ea7a8787ae390"></a>
constexpr static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#abb6528ba65ba4fbb472ea7a8787ae390">default_capacity</a> { 200 }</td></tr>
<tr class="memdesc:abb6528ba65ba4fbb472ea7a8787ae390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default capacity for the task queue. <br /></td></tr>
<tr class="separator:abb6528ba65ba4fbb472ea7a8787ae390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9fc4366a8155f3cc7431bad252dc09"><td class="memItemLeft" align="right" valign="top"><a id="a9d9fc4366a8155f3cc7431bad252dc09"></a>
constexpr static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a9d9fc4366a8155f3cc7431bad252dc09">max_capacity</a> { 10'000'000 }</td></tr>
<tr class="memdesc:a9d9fc4366a8155f3cc7431bad252dc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum possible capacity for the task queue. <br /></td></tr>
<tr class="separator:a9d9fc4366a8155f3cc7431bad252dc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bf2bc531e64e369d9b736c560ae03e"><td class="memItemLeft" align="right" valign="top"><a id="a66bf2bc531e64e369d9b736c560ae03e"></a>
constexpr static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html#a66bf2bc531e64e369d9b736c560ae03e">max_threads</a> { 10'000 }</td></tr>
<tr class="memdesc:a66bf2bc531e64e369d9b736c560ae03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum possible number of threads. <br /></td></tr>
<tr class="separator:a66bf2bc531e64e369d9b736c560ae03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0fad3bafdc1110161c98117f68f76a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fad3bafdc1110161c98117f68f76a5f">&#9670;&nbsp;</a></span>~ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gul17::ThreadPool::~ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct the <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> and join all threads. </p>
<p>This destructor blocks until all threads have terminated. Work that has not yet been started in one of the threads gets canceled, but work that has already been assigned to a thread continues to be executed until it completes. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ab799d844fe310740c39d7465ec192d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab799d844fe310740c39d7465ec192d">&#9670;&nbsp;</a></span>add_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a>&lt;<a class="el" href="group__traits__h.html#gafe64b28f921c9dabcc174187f6c52947">invoke_result_t</a>&lt;Function, <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a>&amp;&gt; &gt; gul17::ThreadPool::add_task </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimePoint&#160;</td>
          <td class="paramname"><em>start_time</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a task. </p>
<p>There are multiple overloads of this function for variations of the arguments:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fct</td><td>A function object or function pointer to be executed. This function can have an arbitrary return type and may either take no arguments (<code>T fct()</code>) or a reference to the <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> by which it gets executed (<code>T fct(ThreadPool&amp;)</code>). </td></tr>
    <tr><td class="paramname">start_time</td><td>Earliest time point at which the task is to be started </td></tr>
    <tr><td class="paramname">name</td><td>Optional name for the task (mainly for debugging)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classgul17_1_1ThreadPool_1_1TaskHandle.html" title="A handle for a task that has (or had) been enqueued on a ThreadPool.">TaskHandle</a> that can be used for inquiries about the state of the task and to retrieve its return value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>is thrown if the queue is full.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pool = <a class="code" href="group__ThreadPool__h.html#gaeb910daff6ce7c95de6d4d468f04fc29">make_thread_pool</a>(2); <span class="comment">// Create a pool with 2 threads</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A simple task that does not interact with the pool</span></div>
<div class="line">pool-&gt;add_task([]() { std::cout &lt;&lt; <span class="stringliteral">&quot;Task 1\n&quot;</span>; });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A task that schedules another task to start two seconds later</span></div>
<div class="line">pool-&gt;add_task(</div>
<div class="line">    [](ThreadPool&amp; pool)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Task 2\n&quot;</span>;</div>
<div class="line">        pool.add_task([]() { std::cout &lt;&lt; <span class="stringliteral">&quot;Task 3\n&quot;</span>; }, 2s);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A task with a name</span></div>
<div class="line">pool-&gt;add_task([]() { std::cout &lt;&lt; <span class="stringliteral">&quot;Task 4\n&quot;</span>; }, <span class="stringliteral">&quot;Task 4&quot;</span>);</div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>GUL version 2.12.1, <a class="el" href="classgul17_1_1ThreadPool.html#a9ab799d844fe310740c39d7465ec192d" title="Enqueue a task.">add_task()</a> unconditionally accepts mutable function objects </dd></dl>

</div>
</div>
<a id="ad383fc50afd172fc9dfaf9909796ae4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad383fc50afd172fc9dfaf9909796ae4a">&#9670;&nbsp;</a></span>cancel_pending_tasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t gul17::ThreadPool::cancel_pending_tasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all pending tasks from the queue. </p>
<p>This call removes all tasks that have not yet been started from the queue. It has no impact on tasks that are currently being executed.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of tasks that were removed. </dd></dl>

</div>
</div>
<a id="a79212ccd26c724dc40446e9f0d6386db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79212ccd26c724dc40446e9f0d6386db">&#9670;&nbsp;</a></span>make_shared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &gt; gul17::ThreadPool::make_shared </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em> = <code><a class="el" href="classgul17_1_1ThreadPool.html#abb6528ba65ba4fbb472ea7a8787ae390">default_capacity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a thread pool with the desired number of threads and the specified capacity for enqueuing tasks. </p>
<p>The thread pool is allocated in a shared pointer, which is necessary so that task handles can access the pool safely. A <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> cannot be constructed directly.</p>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to the created <a class="el" href="classgul17_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> object. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__ThreadPool__h.html#gaeb910daff6ce7c95de6d4d468f04fc29">gul17::make_thread_pool()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ThreadPool_8h_source.html">ThreadPool.h</a></li>
<li><a class="el" href="ThreadPool_8cc.html">ThreadPool.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer"><small>
  General Utility Library for C++17 &middot;
  <a href="https://www.desy.de/imprint/index_eng.html">Legal Disclosure</a> &middot;
  <a href="https://www.desy.de/data_privacy_policy/index_eng.html">Privacy Policy</a>
  <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
</small></address>
</body>
</html>
