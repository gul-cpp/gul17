<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>General Utility Library for C++17: gul17/statistics.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gul17.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">General Utility Library for C++17
   &#160;<span id="projectnumber">2.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gul17/statistics.h</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Statistical utility functions and classes. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgul17_1_1MinMax.html">gul17::MinMax&lt; DataT, typename, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object that is designed to holds two values: minimum and maximum of something.  <a href="structgul17_1_1MinMax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1StandardDeviationMean.html">gul17::StandardDeviationMean&lt; DataT, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct holding a standard deviation and a mean value.  <a href="classgul17_1_1StandardDeviationMean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5f8c06e67819992eb4484b54f1b67727"><td class="memItemLeft" align="right" valign="top"><a id="ga5f8c06e67819992eb4484b54f1b67727"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga5f8c06e67819992eb4484b54f1b67727">gul17::statistics_result_type</a> = double</td></tr>
<tr class="memdesc:ga5f8c06e67819992eb4484b54f1b67727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to return statistic properties. <br /></td></tr>
<tr class="separator:ga5f8c06e67819992eb4484b54f1b67727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3ddfc52989ba8d616d69eeeb1886c2"><td class="memItemLeft" align="right" valign="top"><a id="gafd3ddfc52989ba8d616d69eeeb1886c2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>gul17::ContainerView&lt; IteratorT &gt;::value_type</b> = std::decay_t&lt; decltype(*begin_)&gt;</td></tr>
<tr class="separator:gafd3ddfc52989ba8d616d69eeeb1886c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacd713dea749a09e29038b0b3c920cabf"><td class="memTemplParams" colspan="2">template&lt;typename ElementT &gt; </td></tr>
<tr class="memitem:gacd713dea749a09e29038b0b3c920cabf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">gul17::ElementAccessor</a> ()</td></tr>
<tr class="memdesc:gacd713dea749a09e29038b0b3c920cabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mock element accessor for containers.  <a href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">More...</a><br /></td></tr>
<tr class="separator:gacd713dea749a09e29038b0b3c920cabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1801639efca8286c21509a11fae25c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gaf1801639efca8286c21509a11fae25c1">gul17::StandardDeviationMean&lt; DataT, typename &gt;::operator DataT</a> () const noexcept</td></tr>
<tr class="memdesc:gaf1801639efca8286c21509a11fae25c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast to DataT results in standard deviation value.  <a href="group__statistics__h.html#gaf1801639efca8286c21509a11fae25c1">More...</a><br /></td></tr>
<tr class="separator:gaf1801639efca8286c21509a11fae25c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae990cbceec5c67f01aba9e7b42cd4cf"><td class="memItemLeft" align="right" valign="top"><a id="gaae990cbceec5c67f01aba9e7b42cd4cf"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gaae990cbceec5c67f01aba9e7b42cd4cf">gul17::StandardDeviationMean&lt; DataT, typename &gt;::sigma</a> () const noexcept -&gt; DataT</td></tr>
<tr class="memdesc:gaae990cbceec5c67f01aba9e7b42cd4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the standard deviation value. <br /></td></tr>
<tr class="separator:gaae990cbceec5c67f01aba9e7b42cd4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace71849cb166bb3efac0a1d914321d8d"><td class="memItemLeft" align="right" valign="top"><a id="gace71849cb166bb3efac0a1d914321d8d"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gace71849cb166bb3efac0a1d914321d8d">gul17::StandardDeviationMean&lt; DataT, typename &gt;::mean</a> () const noexcept -&gt; DataT</td></tr>
<tr class="memdesc:gace71849cb166bb3efac0a1d914321d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the arithmetic mean value. <br /></td></tr>
<tr class="separator:gace71849cb166bb3efac0a1d914321d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab567c2f8f80e4a64c8268eaecb1cdb48"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gab567c2f8f80e4a64c8268eaecb1cdb48"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gab567c2f8f80e4a64c8268eaecb1cdb48">gul17::mean</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:gab567c2f8f80e4a64c8268eaecb1cdb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the arithmetic mean value of all elements in a container.  <a href="group__statistics__h.html#gab567c2f8f80e4a64c8268eaecb1cdb48">More...</a><br /></td></tr>
<tr class="separator:gab567c2f8f80e4a64c8268eaecb1cdb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599b36c9d9c696ef9cb6dedcd8a94c23"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga599b36c9d9c696ef9cb6dedcd8a94c23"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga599b36c9d9c696ef9cb6dedcd8a94c23">gul17::rms</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ga599b36c9d9c696ef9cb6dedcd8a94c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the root mean square of all elements in a container.  <a href="group__statistics__h.html#ga599b36c9d9c696ef9cb6dedcd8a94c23">More...</a><br /></td></tr>
<tr class="separator:ga599b36c9d9c696ef9cb6dedcd8a94c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7247073c9fecc58e7191809eee90478c"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga7247073c9fecc58e7191809eee90478c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga7247073c9fecc58e7191809eee90478c">gul17::median</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ga7247073c9fecc58e7191809eee90478c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the median of all elements in a container.  <a href="group__statistics__h.html#ga7247073c9fecc58e7191809eee90478c">More...</a><br /></td></tr>
<tr class="separator:ga7247073c9fecc58e7191809eee90478c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf7c055a3321c2879bbb3747421e53a"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gadaf7c055a3321c2879bbb3747421e53a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a">gul17::maximum</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:gadaf7c055a3321c2879bbb3747421e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum element value in a container.  <a href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a">More...</a><br /></td></tr>
<tr class="separator:gadaf7c055a3321c2879bbb3747421e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09a79457fb1c1bd6e4a52705c6942c27"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga09a79457fb1c1bd6e4a52705c6942c27"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27">gul17::minimum</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:ga09a79457fb1c1bd6e4a52705c6942c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum element value in a container.  <a href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27">More...</a><br /></td></tr>
<tr class="separator:ga09a79457fb1c1bd6e4a52705c6942c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0607dc23acab7ba0842288e7e29a0c6f"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga0607dc23acab7ba0842288e7e29a0c6f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga0607dc23acab7ba0842288e7e29a0c6f">gul17::min_max</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="structgul17_1_1MinMax.html">MinMax</a>&lt; DataT &gt;</td></tr>
<tr class="memdesc:ga0607dc23acab7ba0842288e7e29a0c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum and maximum element values in a container.  <a href="group__statistics__h.html#ga0607dc23acab7ba0842288e7e29a0c6f">More...</a><br /></td></tr>
<tr class="separator:ga0607dc23acab7ba0842288e7e29a0c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9200adf6197635e1523566f723a6e0"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga8e9200adf6197635e1523566f723a6e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga8e9200adf6197635e1523566f723a6e0">gul17::remove_outliers</a> (ContainerT &amp;&amp;cont, std::size_t outliers, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ContainerT &amp;</td></tr>
<tr class="memdesc:ga8e9200adf6197635e1523566f723a6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements that are far away from other elements.  <a href="group__statistics__h.html#ga8e9200adf6197635e1523566f723a6e0">More...</a><br /></td></tr>
<tr class="separator:ga8e9200adf6197635e1523566f723a6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08c0e478945f6ed693c9bf4f9eac0c6"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gad08c0e478945f6ed693c9bf4f9eac0c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gad08c0e478945f6ed693c9bf4f9eac0c6">gul17::remove_outliers</a> (ContainerT const &amp;cont, std::size_t outliers, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; std::vector&lt; ElementT &gt;</td></tr>
<tr class="memdesc:gad08c0e478945f6ed693c9bf4f9eac0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The original container is not modified.  <a href="group__statistics__h.html#gad08c0e478945f6ed693c9bf4f9eac0c6">More...</a><br /></td></tr>
<tr class="separator:gad08c0e478945f6ed693c9bf4f9eac0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bdac2d193684fe9ef06511b7861613f"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga9bdac2d193684fe9ef06511b7861613f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f">gul17::standard_deviation</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="classgul17_1_1StandardDeviationMean.html">StandardDeviationMean</a>&lt; ResultT &gt;</td></tr>
<tr class="memdesc:ga9bdac2d193684fe9ef06511b7861613f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the standard deviation of all elements in a container.  <a href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f">More...</a><br /></td></tr>
<tr class="separator:ga9bdac2d193684fe9ef06511b7861613f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97eb72160ee26316565c75f1d6f45390"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename OpClosure , typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga97eb72160ee26316565c75f1d6f45390"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga97eb72160ee26316565c75f1d6f45390">gul17::accumulate</a> (ContainerT const &amp;container, OpClosure op, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ga97eb72160ee26316565c75f1d6f45390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate some aggregate value from all elements of a container.  <a href="group__statistics__h.html#ga97eb72160ee26316565c75f1d6f45390">More...</a><br /></td></tr>
<tr class="separator:ga97eb72160ee26316565c75f1d6f45390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbdb6e8abd1c8e28011f6b7c42e1e03"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:gacfbdb6e8abd1c8e28011f6b7c42e1e03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gacfbdb6e8abd1c8e28011f6b7c42e1e03">gul17::mean</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:gacfbdb6e8abd1c8e28011f6b7c42e1e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#gacfbdb6e8abd1c8e28011f6b7c42e1e03">More...</a><br /></td></tr>
<tr class="separator:gacfbdb6e8abd1c8e28011f6b7c42e1e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20c0589f100410843ce4c5784086e03"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:gac20c0589f100410843ce4c5784086e03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gac20c0589f100410843ce4c5784086e03">gul17::rms</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:gac20c0589f100410843ce4c5784086e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#gac20c0589f100410843ce4c5784086e03">More...</a><br /></td></tr>
<tr class="separator:gac20c0589f100410843ce4c5784086e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb5395e5032229c573383e589d0347b"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga5fb5395e5032229c573383e589d0347b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga5fb5395e5032229c573383e589d0347b">gul17::median</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ga5fb5395e5032229c573383e589d0347b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga5fb5395e5032229c573383e589d0347b">More...</a><br /></td></tr>
<tr class="separator:ga5fb5395e5032229c573383e589d0347b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103a9f9b718a6ca8ae8c6b959cf51e5c"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga103a9f9b718a6ca8ae8c6b959cf51e5c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga103a9f9b718a6ca8ae8c6b959cf51e5c">gul17::maximum</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:ga103a9f9b718a6ca8ae8c6b959cf51e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga103a9f9b718a6ca8ae8c6b959cf51e5c">More...</a><br /></td></tr>
<tr class="separator:ga103a9f9b718a6ca8ae8c6b959cf51e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5194d42b5a3b88e9c9b134363623bf9f"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga5194d42b5a3b88e9c9b134363623bf9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga5194d42b5a3b88e9c9b134363623bf9f">gul17::minimum</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:ga5194d42b5a3b88e9c9b134363623bf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga5194d42b5a3b88e9c9b134363623bf9f">More...</a><br /></td></tr>
<tr class="separator:ga5194d42b5a3b88e9c9b134363623bf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fdc644679658370261991532d376c66"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga2fdc644679658370261991532d376c66"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga2fdc644679658370261991532d376c66">gul17::min_max</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="structgul17_1_1MinMax.html">MinMax</a>&lt; DataT &gt;</td></tr>
<tr class="memdesc:ga2fdc644679658370261991532d376c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga2fdc644679658370261991532d376c66">More...</a><br /></td></tr>
<tr class="separator:ga2fdc644679658370261991532d376c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2401994431960fa8a98588ecc879cf5"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:gab2401994431960fa8a98588ecc879cf5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gab2401994431960fa8a98588ecc879cf5">gul17::remove_outliers</a> (IteratorT const &amp;begin, IteratorT const &amp;end, std::size_t outliers, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; std::vector&lt; ElementT &gt;</td></tr>
<tr class="memdesc:gab2401994431960fa8a98588ecc879cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The original container is not modified.  <a href="group__statistics__h.html#gab2401994431960fa8a98588ecc879cf5">More...</a><br /></td></tr>
<tr class="separator:gab2401994431960fa8a98588ecc879cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aee6485604b78ba17a39e74b2c17dfe"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga3aee6485604b78ba17a39e74b2c17dfe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga3aee6485604b78ba17a39e74b2c17dfe">gul17::standard_deviation</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="classgul17_1_1StandardDeviationMean.html">StandardDeviationMean</a>&lt; ResultT &gt;</td></tr>
<tr class="memdesc:ga3aee6485604b78ba17a39e74b2c17dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga3aee6485604b78ba17a39e74b2c17dfe">More...</a><br /></td></tr>
<tr class="separator:ga3aee6485604b78ba17a39e74b2c17dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10509dd5d938901d89fdf6ff92050f0b"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename OpClosure &gt; </td></tr>
<tr class="memitem:ga10509dd5d938901d89fdf6ff92050f0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">gul17::accumulate</a> (IteratorT const &amp;begin, IteratorT const &amp;end, OpClosure op, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ga10509dd5d938901d89fdf6ff92050f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">More...</a><br /></td></tr>
<tr class="separator:ga10509dd5d938901d89fdf6ff92050f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gafe5705c4693a36c83a91b869a30a5fdb"><td class="memItemLeft" align="right" valign="top"><a id="gafe5705c4693a36c83a91b869a30a5fdb"></a>
DataT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gafe5705c4693a36c83a91b869a30a5fdb">gul17::MinMax&lt; DataT, typename, typename &gt;::min</a> { std::numeric_limits&lt;DataT&gt;::<a class="el" href="group__statistics__h.html#ga69e38048e70e51d0a0c547845db42ca9">max</a>() }</td></tr>
<tr class="memdesc:gafe5705c4693a36c83a91b869a30a5fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value. <br /></td></tr>
<tr class="separator:gafe5705c4693a36c83a91b869a30a5fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69e38048e70e51d0a0c547845db42ca9"><td class="memItemLeft" align="right" valign="top"><a id="ga69e38048e70e51d0a0c547845db42ca9"></a>
DataT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga69e38048e70e51d0a0c547845db42ca9">gul17::MinMax&lt; DataT, typename, typename &gt;::max</a> { std::numeric_limits&lt;DataT&gt;::lowest() }</td></tr>
<tr class="memdesc:ga69e38048e70e51d0a0c547845db42ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value. <br /></td></tr>
<tr class="separator:ga69e38048e70e51d0a0c547845db42ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393aa9f815d58dea7a9e5b1622f3849c"><td class="memItemLeft" align="right" valign="top"><a id="ga393aa9f815d58dea7a9e5b1622f3849c"></a>
DataT&#160;</td><td class="memItemRight" valign="bottom"><b>gul17::MinMax&lt; DataT, std::enable_if_t&lt; std::is_floating_point&lt; DataT &gt;::value &gt; &gt;::min</b> { NAN }</td></tr>
<tr class="separator:ga393aa9f815d58dea7a9e5b1622f3849c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dda1e8a476c3b969b1ba35a9633539d"><td class="memItemLeft" align="right" valign="top"><a id="ga9dda1e8a476c3b969b1ba35a9633539d"></a>
DataT&#160;</td><td class="memItemRight" valign="bottom"><b>gul17::MinMax&lt; DataT, std::enable_if_t&lt; std::is_floating_point&lt; DataT &gt;::value &gt; &gt;::max</b> { NAN }</td></tr>
<tr class="separator:ga9dda1e8a476c3b969b1ba35a9633539d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41b786cdff0d61e683e1d9f7b07e6402"><td class="memItemLeft" align="right" valign="top"><a id="ga41b786cdff0d61e683e1d9f7b07e6402"></a>
DataT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga41b786cdff0d61e683e1d9f7b07e6402">gul17::StandardDeviationMean&lt; DataT, typename &gt;::sigma_</a> { NAN }</td></tr>
<tr class="memdesc:ga41b786cdff0d61e683e1d9f7b07e6402"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard deviation (sigma) value. <br /></td></tr>
<tr class="separator:ga41b786cdff0d61e683e1d9f7b07e6402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2d8dd1c111e1d4c19ccbe045097aca7"><td class="memItemLeft" align="right" valign="top"><a id="gab2d8dd1c111e1d4c19ccbe045097aca7"></a>
DataT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gab2d8dd1c111e1d4c19ccbe045097aca7">gul17::StandardDeviationMean&lt; DataT, typename &gt;::mean_</a> { NAN }</td></tr>
<tr class="memdesc:gab2d8dd1c111e1d4c19ccbe045097aca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mean value. <br /></td></tr>
<tr class="separator:gab2d8dd1c111e1d4c19ccbe045097aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57a372636a956a39261edc7173bcabf6"><td class="memItemLeft" >
IteratorT const  &amp;&#160;&#160;&#160;<b>gul17::ContainerView&lt; IteratorT &gt;::begin_</b></td></tr>
<tr class="separator:ga57a372636a956a39261edc7173bcabf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc871c0ebb2145ecd8c17c60caa21fc"><td class="memItemLeft" >
IteratorT const  &amp;&#160;&#160;&#160;<b>gul17::ContainerView&lt; IteratorT &gt;::end_</b></td></tr>
<tr class="separator:gaadc871c0ebb2145ecd8c17c60caa21fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga97eb72160ee26316565c75f1d6f45390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97eb72160ee26316565c75f1d6f45390">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename OpClosure , typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::accumulate </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpClosure&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate some aggregate value from all elements of a container. </p>
<p>This is similar to std::accumulate, but</p><ul>
<li>works on a whole container,</li>
<li>accesses the container elements through an accessor function,</li>
<li>applies the binary operator <code>op</code> to a running sum and each element value,</li>
<li>the sum's type is in the first template parameter, and</li>
<li>the initial value of the sum is its default constructed value.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">op</td><td>Binary operator to aggregate two values into one value </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the aggregate value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>Type of the result value / accumulator </td></tr>
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">accumulate(IteratorT const&amp;, IteratorT const&amp;, OpClosure, Accessor)</a> accepts two iterators instead of a container. </dd></dl>

<p class="reference">References <a class="el" href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">gul17::accumulate()</a>.</p>

</div>
</div>
<a id="ga10509dd5d938901d89fdf6ff92050f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10509dd5d938901d89fdf6ff92050f0b">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename OpClosure &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::accumulate </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpClosure&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">op</td><td>Binary operator to aggregate two values into one value </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga97eb72160ee26316565c75f1d6f45390" title="Calculate some aggregate value from all elements of a container.">accumulate(ContainerT const&amp;, OpClosure, Accessor)</a> accepts a container instead of iterators. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__statistics__h.html#ga97eb72160ee26316565c75f1d6f45390">gul17::accumulate()</a>, <a class="el" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a">gul17::maximum()</a>, <a class="el" href="group__statistics__h.html#gab567c2f8f80e4a64c8268eaecb1cdb48">gul17::mean()</a>, <a class="el" href="group__statistics__h.html#ga0607dc23acab7ba0842288e7e29a0c6f">gul17::min_max()</a>, <a class="el" href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27">gul17::minimum()</a>, <a class="el" href="group__statistics__h.html#ga599b36c9d9c696ef9cb6dedcd8a94c23">gul17::rms()</a>, and <a class="el" href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f">gul17::standard_deviation()</a>.</p>

</div>
</div>
<a id="gacd713dea749a09e29038b0b3c920cabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd713dea749a09e29038b0b3c920cabf">&#9670;&nbsp;</a></span>ElementAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::ElementAccessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mock element accessor for containers. </p>
<p>All functions in <a class="el" href="statistics_8h.html" title="Declaration of statistical utility functions and classes.">statistics.h</a> access the elements of the containers they work on through accessor functions. If the container is simple, i.e. contains just the types we want to work on (like double of std::vector&lt;double&gt;) we can automate the generation of the accessor function, so that the user does not need to specify it.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>Type of the elements in the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to accessor function </dd></dl>

</div>
</div>
<a id="gadaf7c055a3321c2879bbb3747421e53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaf7c055a3321c2879bbb3747421e53a">&#9670;&nbsp;</a></span>maximum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::maximum </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; DataT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum element value in a container. </p>
<p>The value of each element is determined through the accessor function. The maximum value is returned. Its type (DataT, the return type of the accessor) must provide <code>operator==()</code> and <code>operator&lt;=()</code>. If DataT supports not-a-number (NaN) values, such values are ignored. If the container is empty, the return value is NaN (if supported) or <code>std::numeric_limits&lt;DataT&gt;::lowest()</code>.</p>
<p>Hint: If looking for an iterator to the maximum element instead of its value, use <code>std::max_element()</code> from the STL algorithm collection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga103a9f9b718a6ca8ae8c6b959cf51e5c" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">maximum(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container.<br  />
<a class="el" href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27" title="Return the minimum element value in a container.">minimum()</a> returns the <a class="el" href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27" title="Return the minimum element value in a container.">minimum</a> value, <a class="el" href="group__statistics__h.html#ga0607dc23acab7ba0842288e7e29a0c6f" title="Find the minimum and maximum element values in a container.">min_max()</a> returns both the <a class="el" href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27" title="Return the minimum element value in a container.">minimum</a> and the <a class="el" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a" title="Return the maximum element value in a container.">maximum</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.2 </dd></dl>

<p class="reference">References <a class="el" href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">gul17::accumulate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__num__util__h.html#ga5d7392c45ad102cd92183dc861272e66">gul17::within_orders()</a>.</p>

</div>
</div>
<a id="ga103a9f9b718a6ca8ae8c6b959cf51e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga103a9f9b718a6ca8ae8c6b959cf51e5c">&#9670;&nbsp;</a></span>maximum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::maximum </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; DataT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>max(ContainerT const&amp;, Accessor) accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="gab567c2f8f80e4a64c8268eaecb1cdb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab567c2f8f80e4a64c8268eaecb1cdb48">&#9670;&nbsp;</a></span>mean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::mean </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the arithmetic mean value of all elements in a container. </p>
<p>The mean value is calculated by dividing the sum of all elements by the number of elements: <code>mean -&gt; sum 0..n-1 (element i) / n</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the arithmetic mean value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>Type of the result (this is also the type used for holding the sum of all elements and for the division by the number of elements, so make sure it can hold numbers that are big enough) </td></tr>
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#gacfbdb6e8abd1c8e28011f6b7c42e1e03" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">mean(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container. </dd></dl>

<p class="reference">References <a class="el" href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">gul17::accumulate()</a>.</p>

</div>
</div>
<a id="gacfbdb6e8abd1c8e28011f6b7c42e1e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfbdb6e8abd1c8e28011f6b7c42e1e03">&#9670;&nbsp;</a></span>mean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::mean </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#gab567c2f8f80e4a64c8268eaecb1cdb48" title="Calculate the arithmetic mean value of all elements in a container.">mean(ContainerT const&amp;, Accessor)</a> accepts a container instead of iterators. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__statistics__h.html#ga8e9200adf6197635e1523566f723a6e0">gul17::remove_outliers()</a>.</p>

</div>
</div>
<a id="ga7247073c9fecc58e7191809eee90478c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7247073c9fecc58e7191809eee90478c">&#9670;&nbsp;</a></span>median() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::median </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the median of all elements in a container. </p>
<p>The median element is the element that has an equal number of elements higher and lower in value. If the container has an even number of elements there can be no 'middle' element. In this case the two 'middlemost' elements are taken and the arithmetic mean of the two is returned.</p>
<p>Because all elements need to be sorted, the function works with a temporary copy of the original container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the median value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>Type of the result value </td></tr>
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga5fb5395e5032229c573383e589d0347b" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">median(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container. </dd></dl>

</div>
</div>
<a id="ga5fb5395e5032229c573383e589d0347b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fb5395e5032229c573383e589d0347b">&#9670;&nbsp;</a></span>median() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::median </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga7247073c9fecc58e7191809eee90478c" title="Find the median of all elements in a container.">median(ContainerT const&amp;, Accessor)</a> accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="ga0607dc23acab7ba0842288e7e29a0c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0607dc23acab7ba0842288e7e29a0c6f">&#9670;&nbsp;</a></span>min_max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::min_max </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structgul17_1_1MinMax.html">MinMax</a>&lt;DataT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum and maximum element values in a container. </p>
<p>The value of each element is determined through the accessor function. The minimum and the maximum of these values are returned. Their type (DataT, the return type of the accessor) must provide <code>operator==(),</code>operator&lt;=()<code>, and</code>operator&gt;=()`. If DataT supports not-a-number (NaN) values, such values are ignored. If the container is empty, the return values are NaN (if supported) or <code>std::numeric_limits&lt;DataT&gt;::max()</code> for the minimum and <code>std::numeric_limits&lt;DataT&gt;::lowest()</code> for the maximum.</p>
<p>This behaves like (symbolic code): </p><div class="fragment"><div class="line">std::minmax_element(std::transform(mycontainer, accessor))</div>
</div><!-- fragment --><p> without constructing a temporary container and without the ownership problems that would arise from minmax_element usage on a temporary container.</p>
<p>Hint: If looking for iterators to the minimum and maximum element instead of their values, use <code>std::minmax_element()</code> from the STL algorithm collection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum and maximum values stored in a MinMax&lt;DataT&gt; object.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga2fdc644679658370261991532d376c66" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">min_max(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container.<br  />
<a class="el" href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27" title="Return the minimum element value in a container.">minimum()</a> returns only the <a class="el" href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27" title="Return the minimum element value in a container.">minimum</a> value, <a class="el" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a" title="Return the maximum element value in a container.">maximum()</a> only the <a class="el" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a" title="Return the maximum element value in a container.">maximum</a> value. </dd></dl>

<p class="reference">References <a class="el" href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">gul17::accumulate()</a>.</p>

</div>
</div>
<a id="ga2fdc644679658370261991532d376c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fdc644679658370261991532d376c66">&#9670;&nbsp;</a></span>min_max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::min_max </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structgul17_1_1MinMax.html">MinMax</a>&lt;DataT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga0607dc23acab7ba0842288e7e29a0c6f" title="Find the minimum and maximum element values in a container.">min_max(ContainerT const&amp;, Accessor)</a> accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="ga09a79457fb1c1bd6e4a52705c6942c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09a79457fb1c1bd6e4a52705c6942c27">&#9670;&nbsp;</a></span>minimum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::minimum </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; DataT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum element value in a container. </p>
<p>The value of each element is determined through the accessor function. The minimum value is returned. Its type (DataT, the return type of the accessor) must provide <code>operator==()</code> and <code>operator&gt;=()</code>. If DataT supports not-a-number (NaN) values, such values are ignored. If the container is empty, the return value is NaN (if supported) or <code>std::numeric_limits&lt;DataT&gt;::max()</code>.</p>
<p>Hint: If looking for an iterator to the minimum element instead of its value, use <code>std::min_element()</code> from the STL algorithm collection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga5194d42b5a3b88e9c9b134363623bf9f" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">minimum(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container.<br  />
<a class="el" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a" title="Return the maximum element value in a container.">maximum()</a> returns the <a class="el" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a" title="Return the maximum element value in a container.">maximum</a> value, <a class="el" href="group__statistics__h.html#ga0607dc23acab7ba0842288e7e29a0c6f" title="Find the minimum and maximum element values in a container.">min_max()</a> returns both the <a class="el" href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27" title="Return the minimum element value in a container.">minimum</a> and the <a class="el" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a" title="Return the maximum element value in a container.">maximum</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.2 </dd></dl>

<p class="reference">References <a class="el" href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">gul17::accumulate()</a>.</p>

</div>
</div>
<a id="ga5194d42b5a3b88e9c9b134363623bf9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5194d42b5a3b88e9c9b134363623bf9f">&#9670;&nbsp;</a></span>minimum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::minimum </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; DataT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>max(ContainerT const&amp;, Accessor) accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="gaf1801639efca8286c21509a11fae25c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1801639efca8286c21509a11fae25c1">&#9670;&nbsp;</a></span>operator DataT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , typename  = std::enable_if_t&lt;std::is_floating_point&lt;DataT&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul17_1_1StandardDeviationMean.html">gul17::StandardDeviationMean</a>&lt; DataT, typename &gt;::operator DataT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast to DataT results in standard deviation value. </p>
<p>The conversion operator is not explicit, so any implicit conversion from DataT to the desired type is also conducted.</p>
<p>For example the following works: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sdm = StandardDeviationMean&lt;float&gt;{ 3.0, 4.0 };</div>
<div class="line"><span class="keywordtype">long</span> <span class="keywordtype">double</span> <a class="code" href="group__statistics__h.html#gaae990cbceec5c67f01aba9e7b42cd4cf">sigma</a> = sdm; <span class="comment">// implicit conversion from float to long double</span></div>
<div class="ttc" id="agroup__statistics__h_html_gaae990cbceec5c67f01aba9e7b42cd4cf"><div class="ttname"><a href="group__statistics__h.html#gaae990cbceec5c67f01aba9e7b42cd4cf">gul17::StandardDeviationMean::sigma</a></div><div class="ttdeci">auto sigma() const noexcept -&gt; DataT</div><div class="ttdoc">Get the standard deviation value.</div><div class="ttdef"><b>Definition:</b> statistics.h:126</div></div>
</div><!-- fragment --> 
<p class="reference">References <a class="el" href="group__statistics__h.html#ga41b786cdff0d61e683e1d9f7b07e6402">gul17::StandardDeviationMean&lt; DataT, typename &gt;::sigma_</a>.</p>

</div>
</div>
<a id="ga8e9200adf6197635e1523566f723a6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e9200adf6197635e1523566f723a6e0">&#9670;&nbsp;</a></span>remove_outliers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::remove_outliers </td>
          <td>(</td>
          <td class="paramtype">ContainerT &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>outliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ContainerT&amp;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove elements that are far away from other elements. </p>
<p>The element whose value differs the most from the arithmetic mean of all elements is removed. This process is repeated if more than one outlier is to be removed; specifically, the mean is recalculated from the remaining elements.</p>
<p>The original container is modified. The container needs to be modifiable and have the <code>erase()</code> member function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">outliers</td><td>How many outliers shall be removed </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the container passed in as <code>cont</code> after removal of outliers.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__num__util__h.html#ga751f34d0b7474bfe5e47bf5774754937">gul17::abs()</a>, and <a class="el" href="group__statistics__h.html#gacfbdb6e8abd1c8e28011f6b7c42e1e03">gul17::mean()</a>.</p>

</div>
</div>
<a id="gad08c0e478945f6ed693c9bf4f9eac0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad08c0e478945f6ed693c9bf4f9eac0c6">&#9670;&nbsp;</a></span>remove_outliers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::remove_outliers </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>outliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::vector&lt;ElementT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The original container is not modified. </p>
<p>A copy of the original container without the outlier elements is returned. </p>

<p class="reference">References <a class="el" href="group__statistics__h.html#gab2401994431960fa8a98588ecc879cf5">gul17::remove_outliers()</a>.</p>

</div>
</div>
<a id="gab2401994431960fa8a98588ecc879cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2401994431960fa8a98588ecc879cf5">&#9670;&nbsp;</a></span>remove_outliers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::remove_outliers </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>outliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::vector&lt;ElementT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The original container is not modified. </p>
<p>A copy of the original container with the outerlier elements removed is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">outliers</td><td>How many outliers shall be removed </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__statistics__h.html#gad08c0e478945f6ed693c9bf4f9eac0c6">gul17::remove_outliers()</a>.</p>

</div>
</div>
<a id="ga599b36c9d9c696ef9cb6dedcd8a94c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga599b36c9d9c696ef9cb6dedcd8a94c23">&#9670;&nbsp;</a></span>rms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::rms </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the root mean square of all elements in a container. </p>
<p>The rms value is calculated as the square root of the sum of all squared elements divided by the number of elements: <code>rms -&gt; sqrt (sum 0..n-1 (element i * element i) / n)</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rms value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>Type of the result value </td></tr>
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#gac20c0589f100410843ce4c5784086e03" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">rms(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container. </dd></dl>

<p class="reference">References <a class="el" href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">gul17::accumulate()</a>.</p>

</div>
</div>
<a id="gac20c0589f100410843ce4c5784086e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac20c0589f100410843ce4c5784086e03">&#9670;&nbsp;</a></span>rms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::rms </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ResultT
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga599b36c9d9c696ef9cb6dedcd8a94c23" title="Calculate the root mean square of all elements in a container.">rms(ContainerT const&amp;, Accessor)</a> accepts a container instead of iterators. </dd></dl>

</div>
</div>
<a id="ga9bdac2d193684fe9ef06511b7861613f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bdac2d193684fe9ef06511b7861613f">&#9670;&nbsp;</a></span>standard_deviation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::standard_deviation </td>
          <td>(</td>
          <td class="paramtype">ContainerT const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classgul17_1_1StandardDeviationMean.html">StandardDeviationMean</a>&lt;ResultT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the standard deviation of all elements in a container. </p>
<p>The corrected sample standard deviation is calculated: <code>standard_deviation -&gt; sqrt (sum 0..n-1 ((element i - mean) * (element i - mean)) / (n - 1))</code></p>
<p>The returned <a class="el" href="classgul17_1_1StandardDeviationMean.html" title="A struct holding a standard deviation and a mean value.">StandardDeviationMean</a> object can be used like this: </p><div class="fragment"><div class="line"><span class="keyword">const</span> StandardDeviationMean std_and_mean = <a class="code" href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f">standard_deviation</a>(something);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> std = std_and_mean.sigma();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="group__statistics__h.html#gab567c2f8f80e4a64c8268eaecb1cdb48">mean</a> = std_and_mean.mean();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The cast operator is for people that want to ignore the complicated stuff like this</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> std = <a class="code" href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f">standard_deviation</a>(something);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> std = <a class="code" href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f">standard_deviation</a>(something); <span class="comment">// implicit conversions possible</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Structured binding (C++17)</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> [std, <a class="code" href="group__statistics__h.html#gab567c2f8f80e4a64c8268eaecb1cdb48">mean</a>] = <a class="code" href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f">standard_deviation</a>(something);</div>
<div class="ttc" id="agroup__statistics__h_html_ga9bdac2d193684fe9ef06511b7861613f"><div class="ttname"><a href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f">gul17::standard_deviation</a></div><div class="ttdeci">auto standard_deviation(ContainerT const &amp;container, Accessor accessor=ElementAccessor&lt; ElementT &gt;()) -&gt; StandardDeviationMean&lt; ResultT &gt;</div><div class="ttdoc">Calculate the standard deviation of all elements in a container.</div><div class="ttdef"><b>Definition:</b> statistics.h:552</div></div>
<div class="ttc" id="agroup__statistics__h_html_gab567c2f8f80e4a64c8268eaecb1cdb48"><div class="ttname"><a href="group__statistics__h.html#gab567c2f8f80e4a64c8268eaecb1cdb48">gul17::mean</a></div><div class="ttdeci">auto mean(ContainerT const &amp;container, Accessor accessor=ElementAccessor&lt; ElementT &gt;()) -&gt; ResultT</div><div class="ttdoc">Calculate the arithmetic mean value of all elements in a container.</div><div class="ttdef"><b>Definition:</b> statistics.h:167</div></div>
</div><!-- fragment --><p>If the container is empty, not-a-number is returned for both the standard deviation and the mean value. If it contains only a single element, not-a-number is returned for the standard deviation and the mean value is the value of the element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container of the elements to examine </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the standard deviation and mean values as a <a class="el" href="classgul17_1_1StandardDeviationMean.html" title="A struct holding a standard deviation and a mean value.">StandardDeviationMean</a> object.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>Type of the result value </td></tr>
    <tr><td class="paramname">ContainerT</td><td>Type of the container to examine </td></tr>
    <tr><td class="paramname">ElementT</td><td>Type of an element in the container, i.e. ContainerT::value_type </td></tr>
    <tr><td class="paramname">Accessor</td><td>Type of the accessor function </td></tr>
    <tr><td class="paramname">DataT</td><td>Type returned by the accessor, i.e. numeric value of ElementT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga3aee6485604b78ba17a39e74b2c17dfe" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">standard_deviation(IteratorT const&amp;, IteratorT const&amp;, Accessor)</a> accepts two iterators instead of a container. </dd></dl>

<p class="reference">References <a class="el" href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">gul17::accumulate()</a>.</p>

</div>
</div>
<a id="ga3aee6485604b78ba17a39e74b2c17dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aee6485604b78ba17a39e74b2c17dfe">&#9670;&nbsp;</a></span>standard_deviation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gul17::standard_deviation </td>
          <td>(</td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt;ElementT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classgul17_1_1StandardDeviationMean.html">StandardDeviationMean</a>&lt;ResultT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to first elements to examine in the container </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to examine in the container </td></tr>
    <tr><td class="paramname">accessor</td><td>Helper function to access the numeric value of one container element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f" title="Calculate the standard deviation of all elements in a container.">standard_deviation(ContainerT const&amp;, Accessor)</a> accepts a container instead of iterators. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer"><small>
  General Utility Library for C++17 &middot;
  <a href="https://www.desy.de/imprint/index_eng.html">Legal Disclosure</a> &middot;
  <a href="https://www.desy.de/data_privacy_policy/index_eng.html">Privacy Policy</a>
  <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
</small></address>
</body>
</html>
