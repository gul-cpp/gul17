<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>General Utility Library for C++17: gul17 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gul17.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">General Utility Library for C++17
   &#160;<span id="projectnumber">2.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gul17 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace <a class="el" href="namespacegul17.html" title="Namespace gul17 contains all functions and classes of the General Utility Library.">gul17</a> contains all functions and classes of the General Utility Library. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ConvertingStringView.html">ConvertingStringView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string view that can automatically convert numbers into strings.  <a href="classgul17_1_1ConvertingStringView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1bad__expected__access.html">bad_expected_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception thrown by <a class="el" href="classgul17_1_1expected.html" title="An expected&lt;T, E&gt; is an object that normally contains an &quot;expected&quot; object of type T,...">gul17::expected</a> if value() is called, but no value is present.  <a href="classgul17_1_1bad__expected__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1expected.html">expected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code>expected&lt;T, E&gt;</code> is an object that normally contains an "expected" object of type T, but it can alternatively contain another, "unexpected" or "error" object of type E.  <a href="classgul17_1_1expected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1unexpected.html">unexpected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template for constructing the unexpected value of an expected object.  <a href="classgul17_1_1unexpected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1FinalAction.html">FinalAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgul17_1_1FinalAction.html" title="FinalAction allows us to execute something if the FinalAction object leaves the scope.">FinalAction</a> allows us to execute something if the <a class="el" href="classgul17_1_1FinalAction.html" title="FinalAction allows us to execute something if the FinalAction object leaves the scope.">FinalAction</a> object leaves the scope.  <a href="classgul17_1_1FinalAction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1HexdumpParameterForward.html">HexdumpParameterForward</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object used to enable a convenient syntax to dump things to a stream.  <a href="classgul17_1_1HexdumpParameterForward.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBuffer.html">SlidingBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the back.  <a href="classgul17_1_1SlidingBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SlidingBufferExposed.html">SlidingBufferExposed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="classgul17_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> that exposes the underlying container through its iterator interface.  <a href="classgul17_1_1SlidingBufferExposed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1SmallVector.html">SmallVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A resizable container with contiguous storage that can hold a specified number of elements without allocating memory on the heap.  <a href="classgul17_1_1SmallVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view to a contiguous sequence of objects.  <a href="classgul17_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgul17_1_1MinMax.html">MinMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object that is designed to holds two values: minimum and maximum of something.  <a href="structgul17_1_1MinMax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1StandardDeviationMean.html">StandardDeviationMean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct holding a standard deviation and a mean value.  <a href="classgul17_1_1StandardDeviationMean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool of worker threads with a task queue.  <a href="classgul17_1_1ThreadPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgul17_1_1IsContainerLike.html">IsContainerLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type trait object to determine if a type is a container.  <a href="structgul17_1_1IsContainerLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1Trigger.html">Trigger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that allows sending triggers and waiting for them across different threads.  <a href="classgul17_1_1Trigger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul17_1_1FailToInstantiate.html">FailToInstantiate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to debug types.  <a href="classgul17_1_1FailToInstantiate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9178e4543f9dd79fed8f9a2f41f0f7ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9178e4543f9dd79fed8f9a2f41f0f7ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit__manip__h.html#ga9178e4543f9dd79fed8f9a2f41f0f7ab">BitFunctionReturnType</a> = std::enable_if_t&lt; std::is_integral&lt; T &gt;::value and not std::is_same&lt; std::decay_t&lt; T &gt;, bool &gt;::value, std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga9178e4543f9dd79fed8f9a2f41f0f7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of the bit manipulation functions.  <a href="group__bit__manip__h.html#ga9178e4543f9dd79fed8f9a2f41f0f7ab">More...</a><br /></td></tr>
<tr class="separator:ga9178e4543f9dd79fed8f9a2f41f0f7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f8c06e67819992eb4484b54f1b67727"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga5f8c06e67819992eb4484b54f1b67727">statistics_result_type</a> = double</td></tr>
<tr class="memdesc:ga5f8c06e67819992eb4484b54f1b67727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to return statistic properties. <br /></td></tr>
<tr class="separator:ga5f8c06e67819992eb4484b54f1b67727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69f5f249acf2a036ee38a762b8ffd946"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga69f5f249acf2a036ee38a762b8ffd946"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__traits__h.html#ga69f5f249acf2a036ee38a762b8ffd946">remove_cvref</a> = typename std::remove_cv&lt; std::remove_reference_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga69f5f249acf2a036ee38a762b8ffd946"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template metafunction that removes const, volatile, and reference qualifiers from a type.  <a href="group__traits__h.html#ga69f5f249acf2a036ee38a762b8ffd946">More...</a><br /></td></tr>
<tr class="separator:ga69f5f249acf2a036ee38a762b8ffd946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae97da3df3a03f38d8db131b543ba769e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae97da3df3a03f38d8db131b543ba769e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__traits__h.html#gae97da3df3a03f38d8db131b543ba769e">remove_cvref_t</a> = typename <a class="el" href="group__traits__h.html#ga69f5f249acf2a036ee38a762b8ffd946">remove_cvref</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:gae97da3df3a03f38d8db131b543ba769e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template metafunction that removes const, volatile, and reference qualifiers from a type.  <a href="group__traits__h.html#gae97da3df3a03f38d8db131b543ba769e">More...</a><br /></td></tr>
<tr class="separator:gae97da3df3a03f38d8db131b543ba769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5fd56e1661de2cf5d365ba042a4c3960"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bit__manip__h.html#ga5fd56e1661de2cf5d365ba042a4c3960">endian</a> { <a class="el" href="group__bit__manip__h.html#gga5fd56e1661de2cf5d365ba042a4c3960aaae6635e044ac56046b2893a529b5114">little</a>
, <a class="el" href="group__bit__manip__h.html#gga5fd56e1661de2cf5d365ba042a4c3960ad861877da56b8b4ceb35c8cbfdf65bb4">big</a>
, <a class="el" href="group__bit__manip__h.html#gga5fd56e1661de2cf5d365ba042a4c3960a8e5f3adee38c8fccc13c1f3be0143796">native</a>
 }</td></tr>
<tr class="memdesc:ga5fd56e1661de2cf5d365ba042a4c3960"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum to determine the endianness of multi-byte scalars on the current platform.  <a href="group__bit__manip__h.html#ga5fd56e1661de2cf5d365ba042a4c3960">More...</a><br /></td></tr>
<tr class="separator:ga5fd56e1661de2cf5d365ba042a4c3960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3db063c4badc364a003d2b53f59897"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SlidingBuffer__h.html#gaff3db063c4badc364a003d2b53f59897">ShrinkBehavior</a> { <b>keep_front_elements</b>
, <b>keep_back_elements</b>
 }</td></tr>
<tr class="memdesc:gaff3db063c4badc364a003d2b53f59897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how a SlidingBuffer handles decreases of its size.  <a href="group__SlidingBuffer__h.html#gaff3db063c4badc364a003d2b53f59897">More...</a><br /></td></tr>
<tr class="separator:gaff3db063c4badc364a003d2b53f59897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801711ce088803f135eb84c5e37580c9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ThreadPool__h.html#ga801711ce088803f135eb84c5e37580c9">TaskState</a> { <a class="el" href="group__ThreadPool__h.html#gga801711ce088803f135eb84c5e37580c9a7c6c2e5d48ab37a007cbf70d3ea25fa4">pending</a>
, <a class="el" href="group__ThreadPool__h.html#gga801711ce088803f135eb84c5e37580c9a75101dcdfc88455bcafc9e53e0b06689">running</a>
, <a class="el" href="group__ThreadPool__h.html#gga801711ce088803f135eb84c5e37580c9ad9a22d7a8178d5b42a8750123cbfe5b1">complete</a>
, <a class="el" href="group__ThreadPool__h.html#gga801711ce088803f135eb84c5e37580c9ad5c39a1d9aced393f835f334a1fb9206">canceled</a>
 }</td></tr>
<tr class="memdesc:ga801711ce088803f135eb84c5e37580c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing the state of an individual task.  <a href="group__ThreadPool__h.html#ga801711ce088803f135eb84c5e37580c9">More...</a><br /></td></tr>
<tr class="separator:ga801711ce088803f135eb84c5e37580c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabcfd52ad3b7f39baf3411ce17cb308da"><td class="memTemplParams" colspan="2">template&lt;typename T  = unsigned, typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gabcfd52ad3b7f39baf3411ce17cb308da"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit__manip__h.html#gabcfd52ad3b7f39baf3411ce17cb308da">bit_set</a> (unsigned bit) noexcept -&gt; ReturnT</td></tr>
<tr class="memdesc:gabcfd52ad3b7f39baf3411ce17cb308da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a bit in an integral type.  <a href="group__bit__manip__h.html#gabcfd52ad3b7f39baf3411ce17cb308da">More...</a><br /></td></tr>
<tr class="separator:gabcfd52ad3b7f39baf3411ce17cb308da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga262f7c3fc00986c194a41f244ebbb932"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga262f7c3fc00986c194a41f244ebbb932"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit__manip__h.html#ga262f7c3fc00986c194a41f244ebbb932">bit_set</a> (T previous, unsigned bit) noexcept -&gt; ReturnT</td></tr>
<tr class="memdesc:ga262f7c3fc00986c194a41f244ebbb932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a bit in an integral value.  <a href="group__bit__manip__h.html#ga262f7c3fc00986c194a41f244ebbb932">More...</a><br /></td></tr>
<tr class="separator:ga262f7c3fc00986c194a41f244ebbb932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae238319ac91a5988cee4b0a76bf2f153"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gae238319ac91a5988cee4b0a76bf2f153"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit__manip__h.html#gae238319ac91a5988cee4b0a76bf2f153">bit_reset</a> (T previous, unsigned bit) noexcept -&gt; ReturnT</td></tr>
<tr class="memdesc:gae238319ac91a5988cee4b0a76bf2f153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a bit in an integral value.  <a href="group__bit__manip__h.html#gae238319ac91a5988cee4b0a76bf2f153">More...</a><br /></td></tr>
<tr class="separator:gae238319ac91a5988cee4b0a76bf2f153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd88617ecf25a6ebf0c81ce36382ae0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ReturnT  = BitFunctionReturnType&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gafbd88617ecf25a6ebf0c81ce36382ae0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit__manip__h.html#gafbd88617ecf25a6ebf0c81ce36382ae0">bit_flip</a> (T previous, unsigned bit) noexcept -&gt; ReturnT</td></tr>
<tr class="memdesc:gafbd88617ecf25a6ebf0c81ce36382ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip a bit in an integral value.  <a href="group__bit__manip__h.html#gafbd88617ecf25a6ebf0c81ce36382ae0">More...</a><br /></td></tr>
<tr class="separator:gafbd88617ecf25a6ebf0c81ce36382ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68001b92de396c2489d474e62576d26e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga68001b92de396c2489d474e62576d26e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit__manip__h.html#ga68001b92de396c2489d474e62576d26e">bit_test</a> (T bits, unsigned bit) noexcept</td></tr>
<tr class="memdesc:ga68001b92de396c2489d474e62576d26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a bit in an integral value.  <a href="group__bit__manip__h.html#ga68001b92de396c2489d474e62576d26e">More...</a><br /></td></tr>
<tr class="separator:ga68001b92de396c2489d474e62576d26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42be2087b02670fec844cf9eb0b1d2a3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bit__manip__h.html#ga42be2087b02670fec844cf9eb0b1d2a3">is_big_endian</a> ()</td></tr>
<tr class="memdesc:ga42be2087b02670fec844cf9eb0b1d2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this platform uses big-endian (Motorola) order for storing multi-byte quantities in memory.  <a href="group__bit__manip__h.html#ga42be2087b02670fec844cf9eb0b1d2a3">More...</a><br /></td></tr>
<tr class="separator:ga42be2087b02670fec844cf9eb0b1d2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e3ed27c718b9df4e3a11c829c49bfd"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bit__manip__h.html#ga13e3ed27c718b9df4e3a11c829c49bfd">is_little_endian</a> ()</td></tr>
<tr class="memdesc:ga13e3ed27c718b9df4e3a11c829c49bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this platform uses little-endian (Intel) order for storing multi-byte quantities in memory.  <a href="group__bit__manip__h.html#ga13e3ed27c718b9df4e3a11c829c49bfd">More...</a><br /></td></tr>
<tr class="separator:ga13e3ed27c718b9df4e3a11c829c49bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689d039a86e0a03afdb6cb6d80ec853d"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__case__ascii__h.html#ga689d039a86e0a03afdb6cb6d80ec853d">lowercase_ascii</a> (char c) noexcept</td></tr>
<tr class="memdesc:ga689d039a86e0a03afdb6cb6d80ec853d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ASCII lowercase equivalent of the given character (or the unchanged character, if it is not an ASCII letter).  <a href="group__case__ascii__h.html#ga689d039a86e0a03afdb6cb6d80ec853d">More...</a><br /></td></tr>
<tr class="separator:ga689d039a86e0a03afdb6cb6d80ec853d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764e0c1da9b639afba0d610eede7665c"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__case__ascii__h.html#ga764e0c1da9b639afba0d610eede7665c">lowercase_ascii</a> (std::string_view str)</td></tr>
<tr class="memdesc:ga764e0c1da9b639afba0d610eede7665c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the given string in which all ASCII characters are replaced by their lowercase equivalents.  <a href="group__case__ascii__h.html#ga764e0c1da9b639afba0d610eede7665c">More...</a><br /></td></tr>
<tr class="separator:ga764e0c1da9b639afba0d610eede7665c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3ca090a7897177beaa269348b921ac"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__case__ascii__h.html#ga5d3ca090a7897177beaa269348b921ac">lowercase_ascii_inplace</a> (std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:ga5d3ca090a7897177beaa269348b921ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all ASCII characters in a string by their lowercase equivalents.  <a href="group__case__ascii__h.html#ga5d3ca090a7897177beaa269348b921ac">More...</a><br /></td></tr>
<tr class="separator:ga5d3ca090a7897177beaa269348b921ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d90e3c757ea7cba00cb8e472687953e"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__case__ascii__h.html#ga9d90e3c757ea7cba00cb8e472687953e">uppercase_ascii</a> (char c) noexcept</td></tr>
<tr class="memdesc:ga9d90e3c757ea7cba00cb8e472687953e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ASCII uppercase equivalent of the given character (or the unchanged character, if it is not an ASCII letter).  <a href="group__case__ascii__h.html#ga9d90e3c757ea7cba00cb8e472687953e">More...</a><br /></td></tr>
<tr class="separator:ga9d90e3c757ea7cba00cb8e472687953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf757f01a283cdb1bc30ad685a7b12439"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__case__ascii__h.html#gaf757f01a283cdb1bc30ad685a7b12439">uppercase_ascii</a> (std::string_view str)</td></tr>
<tr class="memdesc:gaf757f01a283cdb1bc30ad685a7b12439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the given string in which all ASCII characters are replaced by their uppercase equivalents.  <a href="group__case__ascii__h.html#gaf757f01a283cdb1bc30ad685a7b12439">More...</a><br /></td></tr>
<tr class="separator:gaf757f01a283cdb1bc30ad685a7b12439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43cb53a208573785d4860ea9ec949e31"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__case__ascii__h.html#ga43cb53a208573785d4860ea9ec949e31">uppercase_ascii_inplace</a> (std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:ga43cb53a208573785d4860ea9ec949e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all ASCII characters in a string by their uppercase equivalents.  <a href="group__case__ascii__h.html#ga43cb53a208573785d4860ea9ec949e31">More...</a><br /></td></tr>
<tr class="separator:ga43cb53a208573785d4860ea9ec949e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3443234f767248cd9ea020b0163b9f6b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cat__h.html#ga3443234f767248cd9ea020b0163b9f6b">cat</a> ()</td></tr>
<tr class="memdesc:ga3443234f767248cd9ea020b0163b9f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently concatenate an arbitrary number of strings and numbers.  <a href="group__cat__h.html#ga3443234f767248cd9ea020b0163b9f6b">More...</a><br /></td></tr>
<tr class="separator:ga3443234f767248cd9ea020b0163b9f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10c7bdd306a80eafee155730a3030fdf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cat__h.html#ga10c7bdd306a80eafee155730a3030fdf">cat</a> (const <a class="el" href="classgul17_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s)</td></tr>
<tr class="separator:ga10c7bdd306a80eafee155730a3030fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad014347bb1df939d8d246e61ce1b8ef5"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cat__h.html#gad014347bb1df939d8d246e61ce1b8ef5">cat</a> (const <a class="el" href="classgul17_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s1, const <a class="el" href="classgul17_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s2)</td></tr>
<tr class="separator:gad014347bb1df939d8d246e61ce1b8ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5900860361ddcd1c2dfdfb25100a9778"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cat__h.html#ga5900860361ddcd1c2dfdfb25100a9778">cat</a> (const <a class="el" href="classgul17_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s1, const <a class="el" href="classgul17_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s2, const <a class="el" href="classgul17_1_1ConvertingStringView.html">ConvertingStringView</a> &amp;s3)</td></tr>
<tr class="separator:ga5900860361ddcd1c2dfdfb25100a9778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada7801f9916037a346c0b4dc803c1750"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cat__h.html#gada7801f9916037a346c0b4dc803c1750">cat</a> (std::initializer_list&lt; <a class="el" href="classgul17_1_1ConvertingStringView.html">ConvertingStringView</a> &gt; pieces)</td></tr>
<tr class="separator:gada7801f9916037a346c0b4dc803c1750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d411315b31a3d7b46c98df80e6e648"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = std::enable_if_t&lt;(sizeof...(Args) &gt; 3)&gt;&gt; </td></tr>
<tr class="memitem:gad6d411315b31a3d7b46c98df80e6e648"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cat__h.html#gad6d411315b31a3d7b46c98df80e6e648">cat</a> (const Args &amp;... args)</td></tr>
<tr class="separator:gad6d411315b31a3d7b46c98df80e6e648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaba0299998c184eb1b03cd9c59ec52fa"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__escape__h.html#gaaba0299998c184eb1b03cd9c59ec52fa">escape</a> (std::string_view in)</td></tr>
<tr class="memdesc:gaaba0299998c184eb1b03cd9c59ec52fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string that looks like an ASCII-only C string literal of the input string.  <a href="group__escape__h.html#gaaba0299998c184eb1b03cd9c59ec52fa">More...</a><br /></td></tr>
<tr class="separator:gaaba0299998c184eb1b03cd9c59ec52fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9452c9875c847089dc589da7b754f271"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__escape__h.html#ga9452c9875c847089dc589da7b754f271">unescape</a> (std::string_view in)</td></tr>
<tr class="memdesc:ga9452c9875c847089dc589da7b754f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a string with escaped characters to get the original string back.  <a href="group__escape__h.html#ga9452c9875c847089dc589da7b754f271">More...</a><br /></td></tr>
<tr class="separator:ga9452c9875c847089dc589da7b754f271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741979a4ab519fff85123ea0ef4acd13"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga741979a4ab519fff85123ea0ef4acd13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1FinalAction.html">FinalAction</a>&lt; typename std::decay_t&lt; F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__finalizer__h.html#ga741979a4ab519fff85123ea0ef4acd13">finally</a> (F &amp;&amp;f) noexcept</td></tr>
<tr class="memdesc:ga741979a4ab519fff85123ea0ef4acd13"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__finalizer__h.html#ga741979a4ab519fff85123ea0ef4acd13" title="finally() - convenience function to generate a FinalAction">finally()</a> - convenience function to generate a <a class="el" href="classgul17_1_1FinalAction.html" title="FinalAction allows us to execute something if the FinalAction object leaves the scope.">FinalAction</a>  <a href="group__finalizer__h.html#ga741979a4ab519fff85123ea0ef4acd13">More...</a><br /></td></tr>
<tr class="separator:ga741979a4ab519fff85123ea0ef4acd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0e815c4b6642ef1a43ff5a51e0ff22"><td class="memTemplParams" colspan="2">template&lt;typename IntTypeA , typename IntTypeB &gt; </td></tr>
<tr class="memitem:gafe0e815c4b6642ef1a43ff5a51e0ff22"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gcd__lcm__h.html#gafe0e815c4b6642ef1a43ff5a51e0ff22">gcd</a> (IntTypeA a, IntTypeB b)</td></tr>
<tr class="memdesc:gafe0e815c4b6642ef1a43ff5a51e0ff22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the greatest common divisor of two integers using the Euclidean algorithm.  <a href="group__gcd__lcm__h.html#gafe0e815c4b6642ef1a43ff5a51e0ff22">More...</a><br /></td></tr>
<tr class="separator:gafe0e815c4b6642ef1a43ff5a51e0ff22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f7c20a25400002d12658780d669419"><td class="memTemplParams" colspan="2">template&lt;typename IntTypeA , typename IntTypeB &gt; </td></tr>
<tr class="memitem:ga33f7c20a25400002d12658780d669419"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gcd__lcm__h.html#ga33f7c20a25400002d12658780d669419">lcm</a> (IntTypeA a, IntTypeB b)</td></tr>
<tr class="memdesc:ga33f7c20a25400002d12658780d669419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the least common multiple of two integers.  <a href="group__gcd__lcm__h.html#ga33f7c20a25400002d12658780d669419">More...</a><br /></td></tr>
<tr class="separator:ga33f7c20a25400002d12658780d669419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d160c58874f7d0db82a26540979cc4"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename  = std::enable_if_t&lt;detail::IsHexDumpIterator&lt;IteratorT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga30d160c58874f7d0db82a26540979cc4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hexdump__h.html#ga30d160c58874f7d0db82a26540979cc4">hexdump</a> (IteratorT begin, IteratorT end, std::string_view prompt=&quot;&quot;)</td></tr>
<tr class="memdesc:ga30d160c58874f7d0db82a26540979cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a hexdump of a data range and return it as a string.  <a href="group__hexdump__h.html#ga30d160c58874f7d0db82a26540979cc4">More...</a><br /></td></tr>
<tr class="separator:ga30d160c58874f7d0db82a26540979cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5050f12a531583a59d680e77717143"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename  = std::enable_if_t&lt;detail::IsHexDumpContainer&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga9b5050f12a531583a59d680e77717143"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hexdump__h.html#ga9b5050f12a531583a59d680e77717143">hexdump</a> (const ContainerT &amp;cont, std::string_view prompt=&quot;&quot;)</td></tr>
<tr class="memdesc:ga9b5050f12a531583a59d680e77717143"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__hexdump__h.html#ga9b5050f12a531583a59d680e77717143">More...</a><br /></td></tr>
<tr class="separator:ga9b5050f12a531583a59d680e77717143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab11edd8d6315f8fa9ad51f7ef533a754"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename  = std::enable_if_t&lt;detail::IsHexDumpIterator&lt;IteratorT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gab11edd8d6315f8fa9ad51f7ef533a754"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1HexdumpParameterForward.html">HexdumpParameterForward</a>&lt; const IteratorT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hexdump__h.html#gab11edd8d6315f8fa9ad51f7ef533a754">hexdump_stream</a> (const IteratorT &amp;begin, const IteratorT &amp;end, std::string prompt=&quot;&quot;)</td></tr>
<tr class="memdesc:gab11edd8d6315f8fa9ad51f7ef533a754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a hexdump of a data range that can be efficiently written to a stream using operator&lt;&lt;.  <a href="group__hexdump__h.html#gab11edd8d6315f8fa9ad51f7ef533a754">More...</a><br /></td></tr>
<tr class="separator:gab11edd8d6315f8fa9ad51f7ef533a754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3497e08d2d2aa28dcee007438a76fada"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename  = std::enable_if_t&lt;detail::IsHexDumpContainer&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga3497e08d2d2aa28dcee007438a76fada"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1HexdumpParameterForward.html">HexdumpParameterForward</a>&lt; const decltype(std::declval&lt; ContainerT &gt;).cbegin())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hexdump__h.html#ga3497e08d2d2aa28dcee007438a76fada">hexdump_stream</a> (const ContainerT &amp;cont, std::string prompt=&quot;&quot;)</td></tr>
<tr class="memdesc:ga3497e08d2d2aa28dcee007438a76fada"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__hexdump__h.html#ga3497e08d2d2aa28dcee007438a76fada">More...</a><br /></td></tr>
<tr class="separator:ga3497e08d2d2aa28dcee007438a76fada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9903f68548c69d9ac742021359011d"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename  = std::enable_if_t&lt;detail::IsHexDumpContainer&lt;ContainerT&gt;::value,        decltype(HexdumpParameterForward&lt;decltype(std::declval&lt;ContainerT&gt;().cbegin()),                     ContainerT&gt; {}, 0)&gt;&gt; </td></tr>
<tr class="memitem:ga3a9903f68548c69d9ac742021359011d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1HexdumpParameterForward.html">HexdumpParameterForward</a>&lt; decltype(std::declval&lt; ContainerT &gt;).cbegin()), ContainerT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hexdump__h.html#ga3a9903f68548c69d9ac742021359011d">hexdump_stream</a> (ContainerT &amp;&amp;cont, std::string prompt=&quot;&quot;)</td></tr>
<tr class="memdesc:ga3a9903f68548c69d9ac742021359011d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__hexdump__h.html#ga3a9903f68548c69d9ac742021359011d">More...</a><br /></td></tr>
<tr class="separator:ga3a9903f68548c69d9ac742021359011d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962c1c726b488e385489c9da17b958da"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer  = std::vector&lt;std::string&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, std::string_view)&gt; </td></tr>
<tr class="memitem:ga962c1c726b488e385489c9da17b958da"><td class="memTemplItemLeft" align="right" valign="top">StringContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__join__split__h.html#ga962c1c726b488e385489c9da17b958da">split</a> (std::string_view text, std::string_view delimiter, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</td></tr>
<tr class="memdesc:ga962c1c726b488e385489c9da17b958da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in a container.  <a href="group__join__split__h.html#ga962c1c726b488e385489c9da17b958da">More...</a><br /></td></tr>
<tr class="separator:ga962c1c726b488e385489c9da17b958da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07881e2a9dc085cf3486402201dddfda"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer  = std::vector&lt;std::string&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, std::string_view)&gt; </td></tr>
<tr class="memitem:ga07881e2a9dc085cf3486402201dddfda"><td class="memTemplItemLeft" align="right" valign="top">StringContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__join__split__h.html#ga07881e2a9dc085cf3486402201dddfda">split</a> (std::string_view text, const std::regex &amp;delimiter, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</td></tr>
<tr class="memdesc:ga07881e2a9dc085cf3486402201dddfda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate a string at all occurrences of a delimiter described by a regular expression, returning the strings between the delimiters in a container.  <a href="group__join__split__h.html#ga07881e2a9dc085cf3486402201dddfda">More...</a><br /></td></tr>
<tr class="separator:ga07881e2a9dc085cf3486402201dddfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047cd1163ecf874f13273237459d8bbd"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer  = std::vector&lt;std::string_view&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, std::string_view)&gt; </td></tr>
<tr class="memitem:ga047cd1163ecf874f13273237459d8bbd"><td class="memTemplItemLeft" align="right" valign="top">StringContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__join__split__h.html#ga047cd1163ecf874f13273237459d8bbd">split_sv</a> (std::string_view text, std::string_view delimiter, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</td></tr>
<tr class="memdesc:ga047cd1163ecf874f13273237459d8bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate a string at all occurrences of a delimiter, returning the strings between the delimiters in a vector.  <a href="group__join__split__h.html#ga047cd1163ecf874f13273237459d8bbd">More...</a><br /></td></tr>
<tr class="separator:ga047cd1163ecf874f13273237459d8bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ad2e9443ebdf9d949a6a8177ef2ad2"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga49ad2e9443ebdf9d949a6a8177ef2ad2"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__join__split__h.html#ga49ad2e9443ebdf9d949a6a8177ef2ad2">join</a> (Iterator begin, Iterator end, std::string_view glue)</td></tr>
<tr class="memdesc:ga49ad2e9443ebdf9d949a6a8177ef2ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate all strings in a range, placing a delimiter between them.  <a href="group__join__split__h.html#ga49ad2e9443ebdf9d949a6a8177ef2ad2">More...</a><br /></td></tr>
<tr class="separator:ga49ad2e9443ebdf9d949a6a8177ef2ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd0ca27dafec6bf2b178060d47999ee6"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer &gt; </td></tr>
<tr class="memitem:gacd0ca27dafec6bf2b178060d47999ee6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__join__split__h.html#gacd0ca27dafec6bf2b178060d47999ee6">join</a> (const StringContainer &amp;parts, std::string_view glue)</td></tr>
<tr class="memdesc:gacd0ca27dafec6bf2b178060d47999ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate all strings in a range, placing a delimiter between them.  <a href="group__join__split__h.html#gacd0ca27dafec6bf2b178060d47999ee6">More...</a><br /></td></tr>
<tr class="separator:gacd0ca27dafec6bf2b178060d47999ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga751f34d0b7474bfe5e47bf5774754937"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:ga751f34d0b7474bfe5e47bf5774754937"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__num__util__h.html#ga751f34d0b7474bfe5e47bf5774754937">abs</a> (ValueT n) noexcept -&gt; std::enable_if_t&lt; std::is_unsigned&lt; ValueT &gt;::value, ValueT &gt;</td></tr>
<tr class="memdesc:ga751f34d0b7474bfe5e47bf5774754937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a number.  <a href="group__num__util__h.html#ga751f34d0b7474bfe5e47bf5774754937">More...</a><br /></td></tr>
<tr class="separator:ga751f34d0b7474bfe5e47bf5774754937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d7392c45ad102cd92183dc861272e66"><td class="memTemplParams" colspan="2">template&lt;typename NumT , typename OrderT , typename  = std::enable_if_t&lt;        std::is_arithmetic&lt;NumT&gt;::value        and std::is_arithmetic&lt;OrderT&gt;::value    &gt;&gt; </td></tr>
<tr class="memitem:ga5d7392c45ad102cd92183dc861272e66"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__num__util__h.html#ga5d7392c45ad102cd92183dc861272e66">within_orders</a> (const NumT a, const NumT b, const OrderT orders) noexcept(false)</td></tr>
<tr class="memdesc:ga5d7392c45ad102cd92183dc861272e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two numbers are almost equal, comparing only some significant digits.  <a href="group__num__util__h.html#ga5d7392c45ad102cd92183dc861272e66">More...</a><br /></td></tr>
<tr class="separator:ga5d7392c45ad102cd92183dc861272e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10bbb72cdc9733a82c57e46cea9aee5"><td class="memTemplParams" colspan="2">template&lt;typename NumT &gt; </td></tr>
<tr class="memitem:gad10bbb72cdc9733a82c57e46cea9aee5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__num__util__h.html#gad10bbb72cdc9733a82c57e46cea9aee5">within_abs</a> (NumT a, NumT b, NumT tol) noexcept</td></tr>
<tr class="memdesc:gad10bbb72cdc9733a82c57e46cea9aee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two numbers are almost equal, allowing for an absolute difference.  <a href="group__num__util__h.html#gad10bbb72cdc9733a82c57e46cea9aee5">More...</a><br /></td></tr>
<tr class="separator:gad10bbb72cdc9733a82c57e46cea9aee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga163a44c96733569ce554f6b00978efb8"><td class="memTemplParams" colspan="2">template&lt;typename NumT , typename  = std::enable_if_t&lt;std::is_floating_point&lt;NumT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga163a44c96733569ce554f6b00978efb8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__num__util__h.html#ga163a44c96733569ce554f6b00978efb8">within_ulp</a> (NumT a, NumT b, unsigned int ulp)</td></tr>
<tr class="memdesc:ga163a44c96733569ce554f6b00978efb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two numbers are almost equal, allowing for a difference of a given number of units-in-the-last-place (ULPs).  <a href="group__num__util__h.html#ga163a44c96733569ce554f6b00978efb8">More...</a><br /></td></tr>
<tr class="separator:ga163a44c96733569ce554f6b00978efb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062602596fe20f29179fd5fd7a2f99fb"><td class="memTemplParams" colspan="2">template&lt;class NumT &gt; </td></tr>
<tr class="memitem:ga062602596fe20f29179fd5fd7a2f99fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr const NumT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__num__util__h.html#ga062602596fe20f29179fd5fd7a2f99fb">clamp</a> (const NumT &amp;v, const NumT &amp;lo, const NumT &amp;hi)</td></tr>
<tr class="memdesc:ga062602596fe20f29179fd5fd7a2f99fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce a value to be within a given range.  <a href="group__num__util__h.html#ga062602596fe20f29179fd5fd7a2f99fb">More...</a><br /></td></tr>
<tr class="separator:ga062602596fe20f29179fd5fd7a2f99fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4cd0bd1a6b7796472ad6fd147f3795a"><td class="memTemplParams" colspan="2">template&lt;class NumT , class Compare &gt; </td></tr>
<tr class="memitem:gaf4cd0bd1a6b7796472ad6fd147f3795a"><td class="memTemplItemLeft" align="right" valign="top">constexpr const NumT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__num__util__h.html#gaf4cd0bd1a6b7796472ad6fd147f3795a">clamp</a> (const NumT &amp;v, const NumT &amp;lo, const NumT &amp;hi, Compare comp)</td></tr>
<tr class="memdesc:gaf4cd0bd1a6b7796472ad6fd147f3795a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__num__util__h.html#gaf4cd0bd1a6b7796472ad6fd147f3795a">More...</a><br /></td></tr>
<tr class="separator:gaf4cd0bd1a6b7796472ad6fd147f3795a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga641195307425644fe4c9359e1b3c70bc"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__replace__h.html#ga641195307425644fe4c9359e1b3c70bc">replace</a> (std::string_view haystack, std::string_view needle, std::string_view hammer)</td></tr>
<tr class="memdesc:ga641195307425644fe4c9359e1b3c70bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of a string within another string, returning the result as a std::string.  <a href="group__replace__h.html#ga641195307425644fe4c9359e1b3c70bc">More...</a><br /></td></tr>
<tr class="separator:ga641195307425644fe4c9359e1b3c70bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a4227f45e7b46639743b018896b6a9"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__replace__h.html#ga70a4227f45e7b46639743b018896b6a9">replace_inplace</a> (std::string &amp;haystack, std::string_view needle, std::string_view hammer)</td></tr>
<tr class="memdesc:ga70a4227f45e7b46639743b018896b6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of a string within another string in-place.  <a href="group__replace__h.html#ga70a4227f45e7b46639743b018896b6a9">More...</a><br /></td></tr>
<tr class="separator:ga70a4227f45e7b46639743b018896b6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83d76c548faa033ede058ee5350b447f"><td class="memTemplParams" colspan="2">template&lt;typename ElementT , size_t in_capacity&gt; </td></tr>
<tr class="memitem:ga83d76c548faa033ede058ee5350b447f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SmallVector__h.html#ga83d76c548faa033ede058ee5350b447f">swap</a> (<a class="el" href="classgul17_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;a, <a class="el" href="classgul17_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;b)</td></tr>
<tr class="memdesc:ga83d76c548faa033ede058ee5350b447f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the contents of one <a class="el" href="classgul17_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> with those of another one.  <a href="group__SmallVector__h.html#ga83d76c548faa033ede058ee5350b447f">More...</a><br /></td></tr>
<tr class="separator:ga83d76c548faa033ede058ee5350b447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab36c13b98f3aff6236d21af98247869c"><td class="memTemplParams" colspan="2">template&lt;typename ElementType , std::size_t Extent&gt; </td></tr>
<tr class="memitem:gab36c13b98f3aff6236d21af98247869c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1span.html">span</a>&lt; const unsigned char,((Extent==dynamic_extent) ? dynamic_extent :sizeof(ElementType) *Extent)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__span__h.html#gab36c13b98f3aff6236d21af98247869c">as_bytes</a> (<a class="el" href="classgul17_1_1span.html">span</a>&lt; ElementType, Extent &gt; s) noexcept</td></tr>
<tr class="memdesc:gab36c13b98f3aff6236d21af98247869c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a constant view to the byte representation of the elements of a given span.  <a href="group__span__h.html#gab36c13b98f3aff6236d21af98247869c">More...</a><br /></td></tr>
<tr class="separator:gab36c13b98f3aff6236d21af98247869c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c8332dee28a604b42e6d2cf096e14cf"><td class="memTemplParams" colspan="2">template&lt;class ElementType , size_t Extent, typename std::enable_if&lt;!std::is_const&lt; ElementType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ga9c8332dee28a604b42e6d2cf096e14cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul17_1_1span.html">span</a>&lt; unsigned char,((Extent==dynamic_extent) ? dynamic_extent :sizeof(ElementType) *Extent)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__span__h.html#ga9c8332dee28a604b42e6d2cf096e14cf">as_writable_bytes</a> (<a class="el" href="classgul17_1_1span.html">span</a>&lt; ElementType, Extent &gt; s) noexcept</td></tr>
<tr class="memdesc:ga9c8332dee28a604b42e6d2cf096e14cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable view to the byte representation of the elements of a given span.  <a href="group__span__h.html#ga9c8332dee28a604b42e6d2cf096e14cf">More...</a><br /></td></tr>
<tr class="separator:ga9c8332dee28a604b42e6d2cf096e14cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7f0833ba9fcd071927036f0e840e4cc"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename E , std::size_t S&gt; </td></tr>
<tr class="memitem:gab7f0833ba9fcd071927036f0e840e4cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__span__h.html#gab7f0833ba9fcd071927036f0e840e4cc">get</a> (<a class="el" href="classgul17_1_1span.html">span</a>&lt; E, S &gt; s) -&gt; decltype(s[N])</td></tr>
<tr class="memdesc:gab7f0833ba9fcd071927036f0e840e4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the Nth element of a given span.  <a href="group__span__h.html#gab7f0833ba9fcd071927036f0e840e4cc">More...</a><br /></td></tr>
<tr class="separator:gab7f0833ba9fcd071927036f0e840e4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd713dea749a09e29038b0b3c920cabf"><td class="memTemplParams" colspan="2">template&lt;typename ElementT &gt; </td></tr>
<tr class="memitem:gacd713dea749a09e29038b0b3c920cabf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a> ()</td></tr>
<tr class="memdesc:gacd713dea749a09e29038b0b3c920cabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mock element accessor for containers.  <a href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">More...</a><br /></td></tr>
<tr class="separator:gacd713dea749a09e29038b0b3c920cabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab567c2f8f80e4a64c8268eaecb1cdb48"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gab567c2f8f80e4a64c8268eaecb1cdb48"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gab567c2f8f80e4a64c8268eaecb1cdb48">mean</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:gab567c2f8f80e4a64c8268eaecb1cdb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the arithmetic mean value of all elements in a container.  <a href="group__statistics__h.html#gab567c2f8f80e4a64c8268eaecb1cdb48">More...</a><br /></td></tr>
<tr class="separator:gab567c2f8f80e4a64c8268eaecb1cdb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599b36c9d9c696ef9cb6dedcd8a94c23"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga599b36c9d9c696ef9cb6dedcd8a94c23"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga599b36c9d9c696ef9cb6dedcd8a94c23">rms</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ga599b36c9d9c696ef9cb6dedcd8a94c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the root mean square of all elements in a container.  <a href="group__statistics__h.html#ga599b36c9d9c696ef9cb6dedcd8a94c23">More...</a><br /></td></tr>
<tr class="separator:ga599b36c9d9c696ef9cb6dedcd8a94c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7247073c9fecc58e7191809eee90478c"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga7247073c9fecc58e7191809eee90478c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga7247073c9fecc58e7191809eee90478c">median</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ga7247073c9fecc58e7191809eee90478c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the median of all elements in a container.  <a href="group__statistics__h.html#ga7247073c9fecc58e7191809eee90478c">More...</a><br /></td></tr>
<tr class="separator:ga7247073c9fecc58e7191809eee90478c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf7c055a3321c2879bbb3747421e53a"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gadaf7c055a3321c2879bbb3747421e53a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a">maximum</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:gadaf7c055a3321c2879bbb3747421e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum element value in a container.  <a href="group__statistics__h.html#gadaf7c055a3321c2879bbb3747421e53a">More...</a><br /></td></tr>
<tr class="separator:gadaf7c055a3321c2879bbb3747421e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09a79457fb1c1bd6e4a52705c6942c27"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga09a79457fb1c1bd6e4a52705c6942c27"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27">minimum</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:ga09a79457fb1c1bd6e4a52705c6942c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum element value in a container.  <a href="group__statistics__h.html#ga09a79457fb1c1bd6e4a52705c6942c27">More...</a><br /></td></tr>
<tr class="separator:ga09a79457fb1c1bd6e4a52705c6942c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0607dc23acab7ba0842288e7e29a0c6f"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga0607dc23acab7ba0842288e7e29a0c6f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga0607dc23acab7ba0842288e7e29a0c6f">min_max</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="structgul17_1_1MinMax.html">MinMax</a>&lt; DataT &gt;</td></tr>
<tr class="memdesc:ga0607dc23acab7ba0842288e7e29a0c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum and maximum element values in a container.  <a href="group__statistics__h.html#ga0607dc23acab7ba0842288e7e29a0c6f">More...</a><br /></td></tr>
<tr class="separator:ga0607dc23acab7ba0842288e7e29a0c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9200adf6197635e1523566f723a6e0"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga8e9200adf6197635e1523566f723a6e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga8e9200adf6197635e1523566f723a6e0">remove_outliers</a> (ContainerT &amp;&amp;cont, std::size_t outliers, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ContainerT &amp;</td></tr>
<tr class="memdesc:ga8e9200adf6197635e1523566f723a6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements that are far away from other elements.  <a href="group__statistics__h.html#ga8e9200adf6197635e1523566f723a6e0">More...</a><br /></td></tr>
<tr class="separator:ga8e9200adf6197635e1523566f723a6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08c0e478945f6ed693c9bf4f9eac0c6"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gad08c0e478945f6ed693c9bf4f9eac0c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gad08c0e478945f6ed693c9bf4f9eac0c6">remove_outliers</a> (ContainerT const &amp;cont, std::size_t outliers, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; std::vector&lt; ElementT &gt;</td></tr>
<tr class="memdesc:gad08c0e478945f6ed693c9bf4f9eac0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The original container is not modified.  <a href="group__statistics__h.html#gad08c0e478945f6ed693c9bf4f9eac0c6">More...</a><br /></td></tr>
<tr class="separator:gad08c0e478945f6ed693c9bf4f9eac0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bdac2d193684fe9ef06511b7861613f"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga9bdac2d193684fe9ef06511b7861613f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f">standard_deviation</a> (ContainerT const &amp;container, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="classgul17_1_1StandardDeviationMean.html">StandardDeviationMean</a>&lt; ResultT &gt;</td></tr>
<tr class="memdesc:ga9bdac2d193684fe9ef06511b7861613f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the standard deviation of all elements in a container.  <a href="group__statistics__h.html#ga9bdac2d193684fe9ef06511b7861613f">More...</a><br /></td></tr>
<tr class="separator:ga9bdac2d193684fe9ef06511b7861613f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97eb72160ee26316565c75f1d6f45390"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename ContainerT , typename ElementT  = typename ContainerT::value_type, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = typename std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename OpClosure , typename  = std::enable_if_t&lt;IsContainerLike&lt;ContainerT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga97eb72160ee26316565c75f1d6f45390"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga97eb72160ee26316565c75f1d6f45390">accumulate</a> (ContainerT const &amp;container, OpClosure op, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ga97eb72160ee26316565c75f1d6f45390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate some aggregate value from all elements of a container.  <a href="group__statistics__h.html#ga97eb72160ee26316565c75f1d6f45390">More...</a><br /></td></tr>
<tr class="separator:ga97eb72160ee26316565c75f1d6f45390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbdb6e8abd1c8e28011f6b7c42e1e03"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:gacfbdb6e8abd1c8e28011f6b7c42e1e03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gacfbdb6e8abd1c8e28011f6b7c42e1e03">mean</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:gacfbdb6e8abd1c8e28011f6b7c42e1e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#gacfbdb6e8abd1c8e28011f6b7c42e1e03">More...</a><br /></td></tr>
<tr class="separator:gacfbdb6e8abd1c8e28011f6b7c42e1e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20c0589f100410843ce4c5784086e03"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:gac20c0589f100410843ce4c5784086e03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gac20c0589f100410843ce4c5784086e03">rms</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:gac20c0589f100410843ce4c5784086e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#gac20c0589f100410843ce4c5784086e03">More...</a><br /></td></tr>
<tr class="separator:gac20c0589f100410843ce4c5784086e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb5395e5032229c573383e589d0347b"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga5fb5395e5032229c573383e589d0347b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga5fb5395e5032229c573383e589d0347b">median</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ga5fb5395e5032229c573383e589d0347b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga5fb5395e5032229c573383e589d0347b">More...</a><br /></td></tr>
<tr class="separator:ga5fb5395e5032229c573383e589d0347b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103a9f9b718a6ca8ae8c6b959cf51e5c"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga103a9f9b718a6ca8ae8c6b959cf51e5c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga103a9f9b718a6ca8ae8c6b959cf51e5c">maximum</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:ga103a9f9b718a6ca8ae8c6b959cf51e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga103a9f9b718a6ca8ae8c6b959cf51e5c">More...</a><br /></td></tr>
<tr class="separator:ga103a9f9b718a6ca8ae8c6b959cf51e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5194d42b5a3b88e9c9b134363623bf9f"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga5194d42b5a3b88e9c9b134363623bf9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga5194d42b5a3b88e9c9b134363623bf9f">minimum</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; DataT</td></tr>
<tr class="memdesc:ga5194d42b5a3b88e9c9b134363623bf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga5194d42b5a3b88e9c9b134363623bf9f">More...</a><br /></td></tr>
<tr class="separator:ga5194d42b5a3b88e9c9b134363623bf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fdc644679658370261991532d376c66"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga2fdc644679658370261991532d376c66"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga2fdc644679658370261991532d376c66">min_max</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="structgul17_1_1MinMax.html">MinMax</a>&lt; DataT &gt;</td></tr>
<tr class="memdesc:ga2fdc644679658370261991532d376c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga2fdc644679658370261991532d376c66">More...</a><br /></td></tr>
<tr class="separator:ga2fdc644679658370261991532d376c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2401994431960fa8a98588ecc879cf5"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:gab2401994431960fa8a98588ecc879cf5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#gab2401994431960fa8a98588ecc879cf5">remove_outliers</a> (IteratorT const &amp;begin, IteratorT const &amp;end, std::size_t outliers, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; std::vector&lt; ElementT &gt;</td></tr>
<tr class="memdesc:gab2401994431960fa8a98588ecc879cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The original container is not modified.  <a href="group__statistics__h.html#gab2401994431960fa8a98588ecc879cf5">More...</a><br /></td></tr>
<tr class="separator:gab2401994431960fa8a98588ecc879cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aee6485604b78ba17a39e74b2c17dfe"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga3aee6485604b78ba17a39e74b2c17dfe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga3aee6485604b78ba17a39e74b2c17dfe">standard_deviation</a> (IteratorT const &amp;begin, IteratorT const &amp;end, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; <a class="el" href="classgul17_1_1StandardDeviationMean.html">StandardDeviationMean</a>&lt; ResultT &gt;</td></tr>
<tr class="memdesc:ga3aee6485604b78ba17a39e74b2c17dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga3aee6485604b78ba17a39e74b2c17dfe">More...</a><br /></td></tr>
<tr class="separator:ga3aee6485604b78ba17a39e74b2c17dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10509dd5d938901d89fdf6ff92050f0b"><td class="memTemplParams" colspan="2">template&lt;typename ResultT  = statistics_result_type, typename IteratorT , typename ElementT  = std::decay_t&lt;decltype(*std::declval&lt;IteratorT&gt;())&gt;, typename Accessor  = std::result_of_t&lt;decltype(ElementAccessor&lt;ElementT&gt;())(ElementT)&gt;(*)(ElementT const&amp;), typename DataT  = std::decay_t&lt;std::result_of_t&lt;Accessor(ElementT)&gt;&gt;, typename OpClosure &gt; </td></tr>
<tr class="memitem:ga10509dd5d938901d89fdf6ff92050f0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">accumulate</a> (IteratorT const &amp;begin, IteratorT const &amp;end, OpClosure op, Accessor accessor=<a class="el" href="group__statistics__h.html#gacd713dea749a09e29038b0b3c920cabf">ElementAccessor</a>&lt; ElementT &gt;()) -&gt; ResultT</td></tr>
<tr class="memdesc:ga10509dd5d938901d89fdf6ff92050f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__statistics__h.html#ga10509dd5d938901d89fdf6ff92050f0b">More...</a><br /></td></tr>
<tr class="separator:ga10509dd5d938901d89fdf6ff92050f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4625b22d58d7f8b7355f715cbec63269"><td class="memTemplParams" colspan="2">template&lt;typename Integer , std::enable_if_t&lt; std::is_integral&lt; Integer &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:ga4625b22d58d7f8b7355f715cbec63269"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string__util__h.html#ga4625b22d58d7f8b7355f715cbec63269">hex_string</a> (Integer v)</td></tr>
<tr class="memdesc:ga4625b22d58d7f8b7355f715cbec63269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hexadecimal ASCII representation of an integer value.  <a href="group__string__util__h.html#ga4625b22d58d7f8b7355f715cbec63269">More...</a><br /></td></tr>
<tr class="separator:ga4625b22d58d7f8b7355f715cbec63269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda56c706913d59caf2fc02de3bb62c1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:gafda56c706913d59caf2fc02de3bb62c1"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string__util__h.html#gafda56c706913d59caf2fc02de3bb62c1">hex_string</a> (Iterator begin, Iterator end, std::string_view separator=&quot;&quot;)</td></tr>
<tr class="memdesc:gafda56c706913d59caf2fc02de3bb62c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hexadecimal ASCII representation of a range of integer values.  <a href="group__string__util__h.html#gafda56c706913d59caf2fc02de3bb62c1">More...</a><br /></td></tr>
<tr class="separator:gafda56c706913d59caf2fc02de3bb62c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac586d66248d2b4a4c3e1a3a59aa8015e"><td class="memTemplParams" colspan="2">template&lt;typename Integer , size_t num_elements, std::enable_if_t&lt; std::is_integral&lt; Integer &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:gac586d66248d2b4a4c3e1a3a59aa8015e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string__util__h.html#gac586d66248d2b4a4c3e1a3a59aa8015e">hex_string</a> (const Integer(&amp;array)[num_elements], std::string_view separator=&quot;&quot;)</td></tr>
<tr class="memdesc:gac586d66248d2b4a4c3e1a3a59aa8015e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hexadecimal ASCII representation of an array with integer values.  <a href="group__string__util__h.html#gac586d66248d2b4a4c3e1a3a59aa8015e">More...</a><br /></td></tr>
<tr class="separator:gac586d66248d2b4a4c3e1a3a59aa8015e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609cb8e436a84a2fe9bc4ba9ae28a668"><td class="memTemplParams" colspan="2">template&lt;typename Container , std::enable_if_t&lt; IsContainerLike&lt; Container &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:ga609cb8e436a84a2fe9bc4ba9ae28a668"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string__util__h.html#ga609cb8e436a84a2fe9bc4ba9ae28a668">hex_string</a> (const Container &amp;container, std::string_view separator=&quot;&quot;)</td></tr>
<tr class="memdesc:ga609cb8e436a84a2fe9bc4ba9ae28a668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hexadecimal ASCII representation of a container with integer values.  <a href="group__string__util__h.html#ga609cb8e436a84a2fe9bc4ba9ae28a668">More...</a><br /></td></tr>
<tr class="separator:ga609cb8e436a84a2fe9bc4ba9ae28a668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8f8f5fd96710507be176488b8237823"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string__util__h.html#gaf8f8f5fd96710507be176488b8237823">repeat</a> (std::string_view str, std::size_t n)</td></tr>
<tr class="memdesc:gaf8f8f5fd96710507be176488b8237823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat a string N times.  <a href="group__string__util__h.html#gaf8f8f5fd96710507be176488b8237823">More...</a><br /></td></tr>
<tr class="separator:gaf8f8f5fd96710507be176488b8237823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe2c31868743b301cb4e8bb9dde1e5b"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string__util__h.html#ga4fe2c31868743b301cb4e8bb9dde1e5b">safe_string</a> (const char *char_ptr, std::size_t length)</td></tr>
<tr class="memdesc:ga4fe2c31868743b301cb4e8bb9dde1e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely construct a std::string from a char pointer and a length.  <a href="group__string__util__h.html#ga4fe2c31868743b301cb4e8bb9dde1e5b">More...</a><br /></td></tr>
<tr class="separator:ga4fe2c31868743b301cb4e8bb9dde1e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ad421dd401435d75be124e576a1c0c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#gaf7ad421dd401435d75be124e576a1c0c">contains</a> (std::string_view haystack, std::string_view needle) noexcept</td></tr>
<tr class="memdesc:gaf7ad421dd401435d75be124e576a1c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string contains another string.  <a href="group__substring__checks__h.html#gaf7ad421dd401435d75be124e576a1c0c">More...</a><br /></td></tr>
<tr class="separator:gaf7ad421dd401435d75be124e576a1c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63b92f7f4b8776323a4fc8f8be3f03fb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#ga63b92f7f4b8776323a4fc8f8be3f03fb">contains</a> (std::string_view haystack, char needle) noexcept</td></tr>
<tr class="memdesc:ga63b92f7f4b8776323a4fc8f8be3f03fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string contains a certain character.  <a href="group__substring__checks__h.html#ga63b92f7f4b8776323a4fc8f8be3f03fb">More...</a><br /></td></tr>
<tr class="separator:ga63b92f7f4b8776323a4fc8f8be3f03fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16fd0806c5d70d5235ec02716b5bda91"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#ga16fd0806c5d70d5235ec02716b5bda91">ends_with</a> (std::string_view str, std::string_view suffix) noexcept</td></tr>
<tr class="memdesc:ga16fd0806c5d70d5235ec02716b5bda91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string ends with another string.  <a href="group__substring__checks__h.html#ga16fd0806c5d70d5235ec02716b5bda91">More...</a><br /></td></tr>
<tr class="separator:ga16fd0806c5d70d5235ec02716b5bda91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf927887c64629088b7aa4854b66cb037"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#gaf927887c64629088b7aa4854b66cb037">ends_with</a> (std::string_view str, char c) noexcept</td></tr>
<tr class="memdesc:gaf927887c64629088b7aa4854b66cb037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string ends with a certain character.  <a href="group__substring__checks__h.html#gaf927887c64629088b7aa4854b66cb037">More...</a><br /></td></tr>
<tr class="separator:gaf927887c64629088b7aa4854b66cb037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c02d3f69550672f481c07f875be3a0"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#ga57c02d3f69550672f481c07f875be3a0">starts_with</a> (std::string_view str, std::string_view prefix) noexcept</td></tr>
<tr class="memdesc:ga57c02d3f69550672f481c07f875be3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string starts with another string.  <a href="group__substring__checks__h.html#ga57c02d3f69550672f481c07f875be3a0">More...</a><br /></td></tr>
<tr class="separator:ga57c02d3f69550672f481c07f875be3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab86ab45d1e22373e4ed62f6b34980f40"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#gab86ab45d1e22373e4ed62f6b34980f40">starts_with</a> (std::string_view str, char c) noexcept</td></tr>
<tr class="memdesc:gab86ab45d1e22373e4ed62f6b34980f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string starts with a certain character.  <a href="group__substring__checks__h.html#gab86ab45d1e22373e4ed62f6b34980f40">More...</a><br /></td></tr>
<tr class="separator:gab86ab45d1e22373e4ed62f6b34980f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71d61ed53c3ed3d8a10e6ae132e633a4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#ga71d61ed53c3ed3d8a10e6ae132e633a4">equals_nocase</a> (std::string_view str1, std::string_view str2) noexcept</td></tr>
<tr class="memdesc:ga71d61ed53c3ed3d8a10e6ae132e633a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string is equal to another one, making no distinction between upper and lower case ASCII characters.  <a href="group__substring__checks__h.html#ga71d61ed53c3ed3d8a10e6ae132e633a4">More...</a><br /></td></tr>
<tr class="separator:ga71d61ed53c3ed3d8a10e6ae132e633a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4773c9f2eafcfdbdb81f6efe45cf2029"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#ga4773c9f2eafcfdbdb81f6efe45cf2029">contains_nocase</a> (std::string_view haystack, std::string_view needle) noexcept</td></tr>
<tr class="memdesc:ga4773c9f2eafcfdbdb81f6efe45cf2029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string contains another string.  <a href="group__substring__checks__h.html#ga4773c9f2eafcfdbdb81f6efe45cf2029">More...</a><br /></td></tr>
<tr class="separator:ga4773c9f2eafcfdbdb81f6efe45cf2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga110aa20ec60bc115118bca7a2a832b64"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#ga110aa20ec60bc115118bca7a2a832b64">contains_nocase</a> (std::string_view haystack, char needle) noexcept</td></tr>
<tr class="memdesc:ga110aa20ec60bc115118bca7a2a832b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string contains a certain character.  <a href="group__substring__checks__h.html#ga110aa20ec60bc115118bca7a2a832b64">More...</a><br /></td></tr>
<tr class="separator:ga110aa20ec60bc115118bca7a2a832b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga864319c8dd61bc2ba530a025a7dcd879"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#ga864319c8dd61bc2ba530a025a7dcd879">ends_with_nocase</a> (std::string_view str, std::string_view suffix) noexcept</td></tr>
<tr class="memdesc:ga864319c8dd61bc2ba530a025a7dcd879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string ends with another string.  <a href="group__substring__checks__h.html#ga864319c8dd61bc2ba530a025a7dcd879">More...</a><br /></td></tr>
<tr class="separator:ga864319c8dd61bc2ba530a025a7dcd879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20d14626e2a3d950e318050dd33b33bd"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#ga20d14626e2a3d950e318050dd33b33bd">ends_with_nocase</a> (std::string_view str, char c) noexcept</td></tr>
<tr class="memdesc:ga20d14626e2a3d950e318050dd33b33bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string ends with a certain character.  <a href="group__substring__checks__h.html#ga20d14626e2a3d950e318050dd33b33bd">More...</a><br /></td></tr>
<tr class="separator:ga20d14626e2a3d950e318050dd33b33bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c7196dc0768f56bcf3893594b3678a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#gae3c7196dc0768f56bcf3893594b3678a">starts_with_nocase</a> (std::string_view str, std::string_view prefix) noexcept</td></tr>
<tr class="memdesc:gae3c7196dc0768f56bcf3893594b3678a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string starts with another string.  <a href="group__substring__checks__h.html#gae3c7196dc0768f56bcf3893594b3678a">More...</a><br /></td></tr>
<tr class="separator:gae3c7196dc0768f56bcf3893594b3678a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bade4bbe1e5acd3362392eb8e9dfdd5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__substring__checks__h.html#ga3bade4bbe1e5acd3362392eb8e9dfdd5">starts_with_nocase</a> (std::string_view str, char c) noexcept</td></tr>
<tr class="memdesc:ga3bade4bbe1e5acd3362392eb8e9dfdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a string starts with a certain character.  <a href="group__substring__checks__h.html#ga3bade4bbe1e5acd3362392eb8e9dfdd5">More...</a><br /></td></tr>
<tr class="separator:ga3bade4bbe1e5acd3362392eb8e9dfdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb910daff6ce7c95de6d4d468f04fc29"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classgul17_1_1ThreadPool.html">ThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ThreadPool__h.html#gaeb910daff6ce7c95de6d4d468f04fc29">make_thread_pool</a> (std::size_t num_threads, std::size_t capacity=<a class="el" href="classgul17_1_1ThreadPool.html#abb6528ba65ba4fbb472ea7a8787ae390">ThreadPool::default_capacity</a>)</td></tr>
<tr class="memdesc:gaeb910daff6ce7c95de6d4d468f04fc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread pool with the desired number of threads and the specified capacity for queuing tasks.  <a href="group__ThreadPool__h.html#gaeb910daff6ce7c95de6d4d468f04fc29">More...</a><br /></td></tr>
<tr class="separator:gaeb910daff6ce7c95de6d4d468f04fc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5dea4dfd085bd80a7d5480a785f5c85"><td class="memItemLeft" align="right" valign="top">std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__time__util__h.html#gab5dea4dfd085bd80a7d5480a785f5c85">tic</a> ()</td></tr>
<tr class="memdesc:gab5dea4dfd085bd80a7d5480a785f5c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current time as a std::chrono time_point.  <a href="group__time__util__h.html#gab5dea4dfd085bd80a7d5480a785f5c85">More...</a><br /></td></tr>
<tr class="separator:gab5dea4dfd085bd80a7d5480a785f5c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ec6790a74542de9d306be8f058a638a"><td class="memTemplParams" colspan="2">template&lt;class TimeUnitType  = std::chrono::duration&lt;double&gt;&gt; </td></tr>
<tr class="memitem:ga7ec6790a74542de9d306be8f058a638a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__time__util__h.html#ga7ec6790a74542de9d306be8f058a638a">toc</a> (std::chrono::steady_clock::time_point t0)</td></tr>
<tr class="memdesc:ga7ec6790a74542de9d306be8f058a638a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elapsed time in seconds (or a different unit) since the given time point.  <a href="group__time__util__h.html#ga7ec6790a74542de9d306be8f058a638a">More...</a><br /></td></tr>
<tr class="separator:ga7ec6790a74542de9d306be8f058a638a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba1f5593c8dd9d3b9e56f20ca103ec29"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:gaba1f5593c8dd9d3b9e56f20ca103ec29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__time__util__h.html#gaba1f5593c8dd9d3b9e56f20ca103ec29">sleep</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;duration, const <a class="el" href="classgul17_1_1Trigger.html">Trigger</a> &amp;trg)</td></tr>
<tr class="memdesc:gaba1f5593c8dd9d3b9e56f20ca103ec29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for at least the given time span, with the option of being woken up from another thread.  <a href="group__time__util__h.html#gaba1f5593c8dd9d3b9e56f20ca103ec29">More...</a><br /></td></tr>
<tr class="separator:gaba1f5593c8dd9d3b9e56f20ca103ec29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae951470ed93bee32c40ac6f6a10646b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__time__util__h.html#gae951470ed93bee32c40ac6f6a10646b5">sleep</a> (double seconds, const <a class="el" href="classgul17_1_1Trigger.html">Trigger</a> &amp;trg)</td></tr>
<tr class="memdesc:gae951470ed93bee32c40ac6f6a10646b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for a given number of seconds, with the option of being woken up from another thread.  <a href="group__time__util__h.html#gae951470ed93bee32c40ac6f6a10646b5">More...</a><br /></td></tr>
<tr class="separator:gae951470ed93bee32c40ac6f6a10646b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad09dc1f04bcab02ad5c1e1e177c5a514"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:gad09dc1f04bcab02ad5c1e1e177c5a514"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__time__util__h.html#gad09dc1f04bcab02ad5c1e1e177c5a514">sleep</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;duration)</td></tr>
<tr class="memdesc:gad09dc1f04bcab02ad5c1e1e177c5a514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for a given time span.  <a href="group__time__util__h.html#gad09dc1f04bcab02ad5c1e1e177c5a514">More...</a><br /></td></tr>
<tr class="separator:gad09dc1f04bcab02ad5c1e1e177c5a514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f66019d4cc7756a71e91589abc37e94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__time__util__h.html#ga9f66019d4cc7756a71e91589abc37e94">sleep</a> (double seconds)</td></tr>
<tr class="memdesc:ga9f66019d4cc7756a71e91589abc37e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for a given number of seconds.  <a href="group__time__util__h.html#ga9f66019d4cc7756a71e91589abc37e94">More...</a><br /></td></tr>
<tr class="separator:ga9f66019d4cc7756a71e91589abc37e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780b17f2b0962916fa927dec67e3bd2d"><td class="memTemplParams" colspan="2">template&lt;typename NumberType &gt; </td></tr>
<tr class="memitem:ga780b17f2b0962916fa927dec67e3bd2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; NumberType &gt;::value and std::is_unsigned&lt; NumberType &gt;::value, std::optional&lt; NumberType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__to__number__h.html#ga780b17f2b0962916fa927dec67e3bd2d">to_number</a> (std::string_view str) noexcept</td></tr>
<tr class="memdesc:ga780b17f2b0962916fa927dec67e3bd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an ASCII std::string_view into a number.  <a href="group__to__number__h.html#ga780b17f2b0962916fa927dec67e3bd2d">More...</a><br /></td></tr>
<tr class="separator:ga780b17f2b0962916fa927dec67e3bd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780b17f2b0962916fa927dec67e3bd2d"><td class="memTemplParams" colspan="2"><a id="ga780b17f2b0962916fa927dec67e3bd2d"></a>
template&lt;typename NumberType &gt; </td></tr>
<tr class="memitem:ga780b17f2b0962916fa927dec67e3bd2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_integral&lt; NumberType &gt;::value and std::is_signed&lt; NumberType &gt;::value, std::optional&lt; NumberType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_number</b> (std::string_view str) noexcept</td></tr>
<tr class="separator:ga780b17f2b0962916fa927dec67e3bd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780b17f2b0962916fa927dec67e3bd2d"><td class="memTemplParams" colspan="2"><a id="ga780b17f2b0962916fa927dec67e3bd2d"></a>
template&lt;typename NumberType &gt; </td></tr>
<tr class="memitem:ga780b17f2b0962916fa927dec67e3bd2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_floating_point&lt; NumberType &gt;::value, std::optional&lt; NumberType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_number</b> (std::string_view str) noexcept</td></tr>
<tr class="separator:ga780b17f2b0962916fa927dec67e3bd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdb8f183d9cd6c5222b2ae783e9ac9e5"><td class="memItemLeft" align="right" valign="top">
template&lt;&gt; </td></tr>
<tr class="memitem:gacdb8f183d9cd6c5222b2ae783e9ac9e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_number&lt; bool &gt;</b> (std::string_view str) noexcept</td></tr>
<tr class="separator:gacdb8f183d9cd6c5222b2ae783e9ac9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b1996358216dec21a5b46ec774cda4"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer  = std::vector&lt;std::string&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, std::string_view)&gt; </td></tr>
<tr class="memitem:gae9b1996358216dec21a5b46ec774cda4"><td class="memTemplItemLeft" align="right" valign="top">StringContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tokenize__h.html#gae9b1996358216dec21a5b46ec774cda4">tokenize</a> (std::string_view str, std::string_view delimiters=<a class="el" href="group__string__util__h.html#ga12c9eb08ac92c6acf6bcc057ffe7d795">default_whitespace_characters</a>, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</td></tr>
<tr class="memdesc:gae9b1996358216dec21a5b46ec774cda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string into a vector of substrings (tokens) delimited by any of the characters in the delimiters string.  <a href="group__tokenize__h.html#gae9b1996358216dec21a5b46ec774cda4">More...</a><br /></td></tr>
<tr class="separator:gae9b1996358216dec21a5b46ec774cda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f861284d132e07e18c7c3501e2d529d"><td class="memTemplParams" colspan="2">template&lt;typename StringContainer  = std::vector&lt;std::string_view&gt;, typename ContainerInsertFct  = void (*)(StringContainer&amp;, std::string_view)&gt; </td></tr>
<tr class="memitem:ga2f861284d132e07e18c7c3501e2d529d"><td class="memTemplItemLeft" align="right" valign="top">StringContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tokenize__h.html#ga2f861284d132e07e18c7c3501e2d529d">tokenize_sv</a> (std::string_view str, std::string_view delimiters=<a class="el" href="group__string__util__h.html#ga12c9eb08ac92c6acf6bcc057ffe7d795">default_whitespace_characters</a>, ContainerInsertFct insert_fct=detail::emplace_back&lt; StringContainer &gt;)</td></tr>
<tr class="memdesc:ga2f861284d132e07e18c7c3501e2d529d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string into a vector of substrings (tokens) delimited by any of the characters in the delimiters string.  <a href="group__tokenize__h.html#ga2f861284d132e07e18c7c3501e2d529d">More...</a><br /></td></tr>
<tr class="separator:ga2f861284d132e07e18c7c3501e2d529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a315b46976cabbf6124ff4739a60f2"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trim__h.html#ga69a315b46976cabbf6124ff4739a60f2">trim</a> (std::string_view str, std::string_view ws_chars=<a class="el" href="group__string__util__h.html#ga12c9eb08ac92c6acf6bcc057ffe7d795">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:ga69a315b46976cabbf6124ff4739a60f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading and trailing whitespace (or a custom set of characters) from a string, returning a new std::string.  <a href="group__trim__h.html#ga69a315b46976cabbf6124ff4739a60f2">More...</a><br /></td></tr>
<tr class="separator:ga69a315b46976cabbf6124ff4739a60f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c0de7d89ab08babb3807474bdf1f21"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trim__h.html#ga01c0de7d89ab08babb3807474bdf1f21">trim_sv</a> (std::string_view str, std::string_view ws_chars=<a class="el" href="group__string__util__h.html#ga12c9eb08ac92c6acf6bcc057ffe7d795">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:ga01c0de7d89ab08babb3807474bdf1f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading and trailing whitespace (or a custom set of characters) from a string, returning a view into the original string.  <a href="group__trim__h.html#ga01c0de7d89ab08babb3807474bdf1f21">More...</a><br /></td></tr>
<tr class="separator:ga01c0de7d89ab08babb3807474bdf1f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f14c637b585f39329e38430277f47e"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trim__h.html#gad7f14c637b585f39329e38430277f47e">trim_left</a> (std::string_view str, std::string_view ws_chars=<a class="el" href="group__string__util__h.html#ga12c9eb08ac92c6acf6bcc057ffe7d795">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:gad7f14c637b585f39329e38430277f47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading whitespace (or a custom set of characters) from a string, returning a new std::string.  <a href="group__trim__h.html#gad7f14c637b585f39329e38430277f47e">More...</a><br /></td></tr>
<tr class="separator:gad7f14c637b585f39329e38430277f47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9be036b419c159e000b5a0d129ce889"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trim__h.html#gaf9be036b419c159e000b5a0d129ce889">trim_left_sv</a> (std::string_view str, std::string_view ws_chars=<a class="el" href="group__string__util__h.html#ga12c9eb08ac92c6acf6bcc057ffe7d795">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:gaf9be036b419c159e000b5a0d129ce889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading whitespace (or a custom set of characters) from a string, returning a view into the original string.  <a href="group__trim__h.html#gaf9be036b419c159e000b5a0d129ce889">More...</a><br /></td></tr>
<tr class="separator:gaf9be036b419c159e000b5a0d129ce889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3f9c8655bad65faf740702558210fa"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trim__h.html#gabf3f9c8655bad65faf740702558210fa">trim_right</a> (std::string_view str, std::string_view ws_chars=<a class="el" href="group__string__util__h.html#ga12c9eb08ac92c6acf6bcc057ffe7d795">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:gabf3f9c8655bad65faf740702558210fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim trailing whitespace (or a custom set of characters) from a string, returning a new std::string.  <a href="group__trim__h.html#gabf3f9c8655bad65faf740702558210fa">More...</a><br /></td></tr>
<tr class="separator:gabf3f9c8655bad65faf740702558210fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7c2dbd70c65949e53c515314f5fe24"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trim__h.html#gacc7c2dbd70c65949e53c515314f5fe24">trim_right_sv</a> (std::string_view str, std::string_view ws_chars=<a class="el" href="group__string__util__h.html#ga12c9eb08ac92c6acf6bcc057ffe7d795">default_whitespace_characters</a>)</td></tr>
<tr class="memdesc:gacc7c2dbd70c65949e53c515314f5fe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim trailing whitespace (or a custom set of characters) from a string, returning a view into the original string.  <a href="group__trim__h.html#gacc7c2dbd70c65949e53c515314f5fe24">More...</a><br /></td></tr>
<tr class="separator:gacc7c2dbd70c65949e53c515314f5fe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37032b0bbf1ea1e986c96205ceea608"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gad37032b0bbf1ea1e986c96205ceea608"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__name__h.html#gad37032b0bbf1ea1e986c96205ceea608">type_name</a> ()</td></tr>
<tr class="memdesc:gad37032b0bbf1ea1e986c96205ceea608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a human readable string describing a type.  <a href="group__type__name__h.html#gad37032b0bbf1ea1e986c96205ceea608">More...</a><br /></td></tr>
<tr class="separator:gad37032b0bbf1ea1e986c96205ceea608"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga12c9eb08ac92c6acf6bcc057ffe7d795"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string__util__h.html#ga12c9eb08ac92c6acf6bcc057ffe7d795">default_whitespace_characters</a> { &quot; \t\r\n\a\b\f\v&quot; }</td></tr>
<tr class="memdesc:ga12c9eb08ac92c6acf6bcc057ffe7d795"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default characters that are treated as whitespace by GUL.  <a href="group__string__util__h.html#ga12c9eb08ac92c6acf6bcc057ffe7d795">More...</a><br /></td></tr>
<tr class="separator:ga12c9eb08ac92c6acf6bcc057ffe7d795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dad680f43482a77efd26b40e9493fa8"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT const std::array&lt; char, 16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string__util__h.html#ga0dad680f43482a77efd26b40e9493fa8">hex_digits</a></td></tr>
<tr class="memdesc:ga0dad680f43482a77efd26b40e9493fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 16 digits for hexadecimal numbers ("0123456789abcdef").  <a href="group__string__util__h.html#ga0dad680f43482a77efd26b40e9493fa8">More...</a><br /></td></tr>
<tr class="separator:ga0dad680f43482a77efd26b40e9493fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0eb6d41b36c48288a12640ccf413efd"><td class="memItemLeft" align="right" valign="top">GUL_EXPORT char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul17.html#af0eb6d41b36c48288a12640ccf413efd">version_git</a></td></tr>
<tr class="memdesc:af0eb6d41b36c48288a12640ccf413efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the git version tag of the sources that the library has been build with.  <a href="namespacegul17.html#af0eb6d41b36c48288a12640ccf413efd">More...</a><br /></td></tr>
<tr class="separator:af0eb6d41b36c48288a12640ccf413efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafee47cbe10d01e04b057214429c921"><td class="memItemLeft" align="right" valign="top"><a id="acafee47cbe10d01e04b057214429c921"></a>
GUL_EXPORT char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegul17.html#acafee47cbe10d01e04b057214429c921">version_api</a></td></tr>
<tr class="memdesc:acafee47cbe10d01e04b057214429c921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the API version of the library. <br /></td></tr>
<tr class="separator:acafee47cbe10d01e04b057214429c921"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af0eb6d41b36c48288a12640ccf413efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0eb6d41b36c48288a12640ccf413efd">&#9670;&nbsp;</a></span>version_git</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GUL_EXPORT char const* gul17::version_git</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds the git version tag of the sources that the library has been build with. </p>
<p>It has the format returned by git describe &ndash;tags &ndash;always &ndash;dirty </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer"><small>
  General Utility Library for C++17 &middot;
  <a href="https://www.desy.de/imprint/index_eng.html">Legal Disclosure</a> &middot;
  <a href="https://www.desy.de/data_privacy_policy/index_eng.html">Privacy Policy</a>
  <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
</small></address>
</body>
</html>
